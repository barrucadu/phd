\documentclass{article}

\usepackage{lmodern}

\title{Techniques for Testing Concurrent and Distributed Systems \\ \large Thesis Outline}
\author{Michael Walker}
\date{September, 2016}

\begin{document}

\maketitle

\begin{abstract}
  Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec
  hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam
  nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis
  natoque penatibus et magnis dis parturient montes, nascetur
  ridiculus mus. Nulla posuere. Donec vitae dolor. Nullam tristique
  diam non turpis. Cras placerat accumsan nulla. Nullam rutrum. Nam
  vestibulum accumsan nisl.
\end{abstract}

\tableofcontents

\pagebreak

\section{Introduction}

% Motivation
Concurrency is notoriously difficult to get right\cite{yang2013}, and
programmer mistakes can have dire consequences\cite{leveson1993}. The
problem stems from the nondeterminism of scheduling: the same program
with the same inputs may produce different results depending on the
schedules chosen at execution time. This makes it difficult to use
traditional testing techniques with concurrent programs, which rely on
the result of executing a test to be deterministic. So-called
``Heisenbugs'' make it difficult to be confident of the correctness of
concurrent programs: no bug has been observed during the testing
process, but how do we \emph{know} that there aren't any? This is a
concern in any testing regime, but nondeterminism makes it
particularly different when concurrency is involved.

Despite the difficulty, concurrency is important for producing many
real-world applications. For example, applications with a lot of input
and output can be more responsive by executing I/O asynchronously.
Concurrency is a useful program structuring technique, and it is here
to stay.

% Explain SCT
\emph{Systematic concurrency testing}
(SCT)\cite{emmi2011,musuvathi2007,musuvathi2008,thomson2014} is a
family of related techniques for avoiding the problem of
nondeterminism when writing tests. SCT techniques aim to execute a
large number of schedules, whilst typically also making use of local
knowledge of the program to reduce the number of schedules needed to
be confident of an accurate result. By trying many schedules, we can
be confident that any bugs which have not been found are unlikely to
be exhibited.

SCT overcomes the scheduling problem by forcing a concurrent program
to use instead a scheduler implemented as part of the testing
framework: either by overriding the concurrency primitives of the
language, or by modifying the program under test to call out to this
new scheduler.

Once the scheduler is under control, schedules can be recorded and
replayed, giving reproducibility. Furthermore, by observing which
scheduling decisions are available at each decision point, possible
schedules can be systematically explored, making different decisions
on subsequent executions.

% State thesis
My thesis is:

\begin{quote}
  Systematic concurrency testing can be used as a lightweight
  alternative to formal methods to gain confidence in the correctness
  of concurrent programs. It can be applied outside of the imperative
  setting in which it is typically presented. It can be applied to
  unusual models of concurrency, such as distributed systems. It can
  \textbf{(whatever chapter 5 is about)}.
\end{quote}

% Roadmap
This document provides an outline for my Ph.D thesis along with a plan
of work for the rest of my programme. Section 2 details the
provisional thesis structure. Section 3 details the plan of work.

\subsection{Scope change}

Due to my internship, I had the idea of applying systematic
concurrency testing to distributed systems, and have begun
investigating. Part of the plan in the progress report was to
investigate the use of types to statically enforce safety properties
of concurrent programs, this has been removed from the plan to make
room for the new distributed systems work.

\section{Thesis structure}

This section gives a description of each chapter in my thesis.

\paragraph{Chapter 1: Introduction} This chapter will explain
systematic concurrency testing, give an overview of the thesis, and
list publications that contributed to the thesis.

\paragraph{Chapter 2: Testing Concurrent Programs} This chapter will
describe more thoroughly what systematic concurrency testing is. It
will present a literature review of works in the area. It will be
divided into three sections:

\begin{itemize}
\item \emph{Section 2.1: Fundamentals of systematic concurrency testing}

  This section will present the fundamental concepts and techniques
  behind systematic concurrency testing.

\item \emph{Section 2.2: Complete and incomplete methods}

  There are two approaches to reducing the schedule-space explored
  when performing SCT. Complete methods mostly focus on applying
  partial-order techniques, common in model checking, to the testing
  setting. This has the benefit of reducing the space greatly, but
  without sacrificing completeness of testing. Incomplete methods do
  make this sacrifice, to obtain even greater reductions. The
  hypothesis behind incomplete methods is that \emph{most} program
  errors can be found with only a small subset of the potential
  executions.
\end{itemize}

\paragraph{Chapter 3: A Concurrency Testing Tool for Haskell} This
chapter will describe an SCT tool for GHC Haskell\cite{walker2015}.
This was a challenging effort, as SCT algorithms are typically
presented in a very minimal setting, whereas GHC Haskell has a very
rich set of concurrency primitives. This chapter will focus on:

\begin{itemize}
\item Haskell concurrency and its operational behaviour, including the
  memory model.
\item The aspects of Haskell which made SCT particularly easy or
  difficult to implement. For example, the typeclass mechanism in
  Haskell made abstracting over the concurrency primitives simple, but
  the great focus on immutable data structures prevented a
  straightforward and direct translation of a standard SCT algorithm.
\item The structure of the tool.
\item A number of case studies of its use.
\item An evaluation of the completeness and usefulness of the tool.
\end{itemize}

\paragraph{Chapter 4: Finding Faults in Distributed Systems} This
chapter will develop techniques for the systematic testing of
distributed systems where in-order reliable message delivery cannot be
guaranteed. If message delivery is reliable, a distributed system can
be thought of as a concurrent program using message-passing and no
shared state. We propose a novel model of the network, inspired by
work on applying SCT to relaxed-memory systems\cite{zhang2015}, to
remove that reliability requirement.

\paragraph{Chapter 5: ???} This is the mythical ``third plank''.

\paragraph{Chapter 6: Conclusions and Future Work} This chapter will
give an overview and draw conclusions from the work set out in the
previous chapters, including a summary of results achieved and thesis
limitations. Then, the chapter will examine some avenues for future
work.

\section{Plan}

\subsection{Current progress}

\subsection{Schedule}

\bibliographystyle{plain}
\bibliography{references}

\end{document}
