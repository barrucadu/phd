Tools are necessary to test concurrency, the standard approach does not suffice.
In this chapter we present and evaluate \dejafu{}, our library for testing
concurrency in Haskell.  We discuss the scope of the tool~\sref{dejafu-scope}
and present our abstraction over the GHC Haskell concurrency
functionality~\sref{dejafu-monadconc}.  We explain how programs using our
abstraction are executed~\sref{dejafu-execution} and
tested~\sref{dejafu-testing}, and argue the correctness of the testing
approach~\sref{dejafu-correctness}.  We present three case
studies~\sref{dejafu-casestudies}, evaluate the usefulness of \dejafu{} for
testing pre-existing code~\sref{dejafu-evaluation}, and finally draw conclusions
and present further work~\sref{dejafu-conclusions}.

This chapter is derived from our previous work \cite{walker2015} and
\cite{YCS-2016-503}.

\todo{Note: discussion of random scheduling is in chapter 6 (swarm) and chapter 9 (eval \& conclusions), so just have brief forward refs in this chapter}

\section{Scope}
\label{sec:dejafu-scope}

We aim to support most of the functionality of GHCâ€™s concurrency API, as made
available through the Control.Concurrent and Control.Exception module
hierarchies, which does not unavoidably require support from the runtime system.

In particular, we do not support:

\begin{itemize}
\item Blocking a thread until a file descriptor becomes available, as this
  introduces an additional source of nondeterminism.
\item Throwing an exception to a thread if it becomes deadlocked, as we cannot
  reliably detect deadlock involving only a subset of threads without support
  from the garbage collector.
\item Querying which capability (OS thread) a Haskell thread is running on, as
  this introduces an additional source of nondeterminism.
\end{itemize}

We also do not yet support \emph{bound threads}: a Haskell thread which will
always run on the same, unique, OS thread.  Bound threads are essential for
using the FFI to call libraries which use thread-local state, to ensure the
Haskell thread always sees its state and never the state of another thread.  We
have a prototype implementation, which is not yet present in a released version
of \dejafu{}\footnote{\url{https://github.com/barrucadu/dejafu/issues/126}}.

\section{Abstracting over I/O}
\label{sec:dejafu-monadconc}

\blindtext

\section{Executing Concurrent Programs}
\label{sec:dejafu-execution}

\blindtext

\section{Testing Concurrent Programs}
\label{sec:dejafu-testing}

\blindtext

\section{Soundness and Completeness}
\label{sec:dejafu-correctness}

\blindtext

\section{Case Studies}
\label{sec:dejafu-casestudies}

\blindtext

\subsection{The auto-update Package}
\subsection{Search Party}
\subsection{The Par Monad}

\section{\dejafu{} in the Wild}
\label{sec:dejafu-evaluation}

\blindtext

\subsection{Richness of the Abstraction}
\subsection{Porting Code}
\subsection{Integration with Existing Tools}

\section{Conclusions and Future Work}
\label{sec:dejafu-conclusions}

\blindtext
