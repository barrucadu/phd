\begin{bquote}{E. W. Dijkstra, 1972\nocite{ewd340}}
  Program testing can be a very effective way to show the presence of
  bugs, but is hopelessly inadequate for showing their absence.
\end{bquote}

\noindent
We set out to make it easier for programmers to write correct
concurrent programs, but have we achieved that?  In this chapter we
summarise and review our contributions, giving some overall
evaluation.

\paragraph{Systematic concurrency testing with rich semantics}
\Cref{chp:dejafu} introduces \dejafu{}.  This is a Haskell tool for
testing Haskell programs, but the underlying techniques are not
Haskell specific.  However, Haskell has an unusually rich concurrency
abstraction, whereas SCT techniques are typically described in the
literature for simple concurrency abstractions.  Even real programming
languages tend to have simple concurrency abstractions.  For example,
Maple\cite{yu2012} is able to test arbitrary pthread programs by
considering just 19 primitive actions, whereas the expression of
Haskell concurrency in \dejafu{} requires 33 (not counting STM).

In Haskell, there are many different operations with partially
overlapping behaviour.  It is not clear that a typical SCT algorithm
would work effectively in this context.  \dejafu{} provides a
convincing demonstration that SCT can be applied to languages with
rich concurrency abstractions.  This is an important stepping-stone to
implementing SCT tools for other similarly rich languages.

\paragraph{Effective bug finding with randomised scheduling}
\Cref{chp:algorithms} introduces the swarm scheduling algorithm.
Benchmark results suggest it performs as well as the PCT
algorithm\cite{burckhardt2010} in terms of bug-finding ability.
Crucially, PCT requires the user to supply parameters derived from the
program under test, whereas swarm scheduling does not.  This
program-agnosticism makes swarm scheduling simpler to implement and
use than PCT, while still finding the bugs.

\paragraph{Discovering properties of concurrent programs}
\Cref{chp:coco} introduces CoCo.  By synthesising program terms and
performing property-based testing, CoCo can give the programmer new
insights into their code.  Like \dejafu{}, this is a Haskell tool, but
the underlying techniques are not Haskell specific.  The underlying
idea is that we can compare sets of program behaviours to make
meaningful claims about the relation between the source programs.
This approach applies not just to concurrent programs, but to
nondeterministic programs in general.

\paragraph{The inevitable exponentials}
Concurrent programs are nondeterministic, and this is where the
difficulty of writing correct concurrent programs comes from.
Fundamentally, testing a concurrent program requires executing it
multiple times with different schedules.  This adds significant
overhead compared to sequential tests, where a single execution
suffices.  Even worse, the number of executions required in the worst
case is exponential in a number of different
factors\cite{musuvathi2007}.

\dejafu{} implements schedule
bounding\cite{emmi2011,musuvathi2008,musuvathi2007} and partial-order
reduction\cite{flanagan2005,godefroid1996} to improve the average
case, but the worst case remains a possibility.  Empirical studies
show that small test cases with two threads and two pre-emptive
context switches suffice for finding many real-world concurrency
bugs\cite{thomson2014}.  So in theory there is a terrible asymptotic
worst case, but in practice test cases are often small enough for this
not to be a significant concern.

\paragraph{The interpretation game}
It can be difficult to look at a passing concurrency test and know
what it is telling us.  We see this with CoCo, where the programmer
may need to run the tool with a variety of different interference
functions to see the full picture.  Properties found with one sort of
concurrent interference may not generalise to cases with different
interference.  Similarly, passing concurrency tests in \dejafu{} may
not generalise to cases where the concurrent environment is different.

It can be difficult to look at a failing concurrency test and diagnose
the problem.  We see this with \dejafu{}, where the resulting
execution traces can expose low-level details of the implementation of
library functions.  Traces may become invalid when library
dependencies change, even if the key scheduling decisions remain the
same.  Which information is truly important is not obvious.  The
\textsc{Concurrit}\cite{elmas2013} tool offers an alternative approach
here, where executions are represented by a small collection of
scheduling constraints, rather than a full trace.  Although intended
for reproducing bugs, \textsc{Concurrit} constraints could be a much
simpler way to present faulty traces.

\paragraph{Contributions}
In summary, we contribute:

\begin{itemize}
\item A library (\dejafu{}) for effectively testing concurrent Haskell
  programs.
\item A convincing demonstration that SCT techniques work well in a
  rich setting.
\item A new scheduling algorithm (swarm scheduling) for randomised
  testing.
\item A tool (CoCo) for discovering properties of concurrent Haskell
  functions.
\end{itemize}
