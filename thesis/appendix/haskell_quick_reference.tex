\todo{Find a Haskell tutorial aimed at functional programmers and rewrite this appendix}

\begin{figure}[b]
  \centering
  \hrulefill
  \input{figs/when.tex}
  \label{fig:when}
\end{figure}

Haskell is a \emph{purely functional} language with \emph{strong static typing}
where values are \emph{first-class}, and which makes a distinction between
\emph{evaluation} (which is \emph{non-strict}) and \emph{execution}.

Let's unpack that:

\begin{itemize}
\item \emph{purely functional} all computation is done by reducing expressions
  to values;
\item \emph{strong static typing} values have a statically-known type and there
  is no implicit conversion between types;
\item \emph{first-class values} any value of any type can be passed as an
  argument to a function, returned as a result from a function, stored in a data
  structure, etc;
\item \emph{evaluation} the process of reducing an expression to a value;
\item \emph{non-strict} expressions are only evaluated when they are needed;
\item \emph{execution} the process of actually peforming IO actions.
\end{itemize}

This appendix is fairly brief.  If you would like a fuller introduction, see the
official tutorial at \url{https://www.haskell.org/tutorial/}

\section*{Evaluation and Execution}

\Cref{fig:when} defines the \verb|when| function, which executes an IO action when
the condition is true.  We can use it by calling it from \verb|main|, the entry
point to a Haskell program.

In many languages, this program would always print \verb|hello world|,
regardless of the value of the condition.  This is because most languages
conflate evaluation and execution and evaluate all function arguments before
calling the function body, which would proceed like so:

\begin{enumerate}
\item Evaluate and execute \verb|1 > 3|, call the result \verb|a|
\item Evaluate and execute \verb|"hello world"|, call the result \verb|b|
\item Evaluate and execute \verb|putStrLn b|, call the result \verb|c|
\item Oh dear!  We printed the string before checking the value of the
  condition!
\end{enumerate}

Many languages use \emph{special forms} to solve this problem: syntactic
structures which have different evaluation rules to the rest of the language.
In Haskell, the series of operations is more like this:

\begin{enumerate}
\item \verb|main = when (1 > 3) (putStrLn "hello world")|
\item \verb|main = if 1 > 3 then putStrLn "hello world" else pure ()|
\item \verb|main = if False then putStrLn "hello world" else pure ()|
\item \verb|main = pure ()|
\end{enumerate}

Evaluation is driven by \emph{demand}, not by the syntactic layout of the
program.  Furthermore, no side-effects are actually executed until \verb|main|
has reduced to a value.  You can think of evaluating a Haskell program as
computing a big list of side-effects to then execute.  The action \verb|pure ()|
can be read as doing nothing.

\begin{figure}[b]
  \hrulefill
  \centering
  \input{figs/compare.tex}
  \label{fig:compare}
\end{figure}

\section*{Types and Classes}

\Cref{fig:compare} defines the \verb|compare| function, which compares two values.
It is \emph{polymorphic}: it can compare two values of any type which has an
instance of the \verb|Ord| \emph{typeclass}.

Types in Haskell have a simple recursive definition:

\begin{itemize}
\item A type may be a concrete type.
\item A type may be a type variable.
\item A type may be a \emph{type constructor} applied to enough other types to
  turn it into a concrete type.
\end{itemize}

We have seen two concrete types so far: \verb|()| (read ``unit'') and
\verb|Bool|.  We have seen two type constructors: \verb|->| (the function arrow)
and \verb|IO|.  In addition, type signatures can contain typeclass constraints,
which constrain the concrete type that a type variable may refer to.  The
\verb|compare| type has one type variable (\verb|a|) and one typeclass
constraint (\verb|Ord a|).

A typeclass is a collection of types which implement some common interface.  We
could define our own \verb|Ord|-like class like so:

\begin{verbatim}
class MyOrd a where
  greaterOrEqual :: a -> a -> Bool

instance MyOrd Int where
  greaterOrEqual a b = a > b || a == b
\end{verbatim}

We could then use this class in function signatures, to require that the
specified type variable have an instance of \verb|MyOrd|.

We are not limited to using the standard Haskell types, we can define our own.
There are three mechanisms for doing so:

\begin{itemize}
\item \emph{type synonyms} let us give a new name to an existing type.
\item \emph{data declarations} let us create a brand new type, possibly
  recursive, possibly with multiple constructors.
\item \emph{newtype declarations} let us create a brand new type with the same
  run-time representation as another, there can only be one constructor.
\end{itemize}

\begin{figure}
  \centering
  \input{figs/list.tex}
  \label{fig:list}
  \hrulefill
\end{figure}

\Cref{fig:list} shows the declaration of a few list data types.  Let us start by
looking at \verb|List|.  Here \verb|List| is a \emph{type constructor}, with
\verb|List a| where \verb|a| is some type being an actual type.  There are two
constructors: \verb|Nil|, representing empty lists; and \verb|Cons|,
representing a list with at least one element.  Other than the syntax, this
should be a familiar type to most programmers.

The \verb|List2| type is similar to \verb|List|, but also names the fields of
\verb|Cons2| with \emph{record selectors}.  This lets us easily access and
update the fields:

\begin{verbatim}
> head (Cons2 5 Nil2)
5
> head ((Cons2 5 Nil2) { head = 6 })
6
\end{verbatim}

Be careful!  The \verb|head| and \verb|tail| accessor functions are partial!
When called with a \verb|Nil2| argument, they will throw an error.

\begin{figure}[b]
  \hrulefill
  \centering
  \input{figs/famonad.tex}
  \label{fig:famonad}
\end{figure}

The \verb|IntList| type synonym gives a new name to \verb|List Int|, but is just
a syntactic shorthand for the programmer.  On the other hand, \verb|IntList2| is
a brand new type, it is a type error to pass a \verb|IntList2| to a function
that expects a \verb|List Int| and vice versa.

\section*{Functors, Applicatives, and Monads}

These three classes, shown in \cref{fig:famonad}, are ubiquitous in Haskell
programming.  Monads turn out to be a very convenient abstraction for modelling
side-effects.  The \verb|>>=| (read ``bind'') operator can be thought of as
doing some monadic computation, and then doing something further with the
result.  We have already seen one monadic type: \verb|IO|.  For example, we
write a program to greet a user like so:

\begin{verbatim}
main :: IO ()
main = putStrLn "What is your name?" >>= \_ ->
       getLine >>= \name ->
       putStrLn ("Hello " ++ name)
\end{verbatim}

There is a convenient syntactic sugar called \emph{do-notation} for expressing
sequences of monadic operations.  We would tend to write the above snippet like
so:

\begin{verbatim}
main :: IO ()
main = do
    putStrLn "What is your name?"
    name <- getLine
    putStrLn ("Hello " ++ name)
\end{verbatim}

Every monad is an applicative, and every applicative is a functor

\section*{Other Assorted Syntax}

\paragraph{Conditionals}
We could have written \verb|when| (in \cref{fig:when}) using \emph{guards} or a
\emph{case expression}:

\begin{multicols}{2}
\begin{verbatim}
when cond action
  | cond      = action
  | otherwise = pure ()
\end{verbatim}
\begin{verbatim}
when cond action = case cond of
  True  -> action
  False -> pure ()
\end{verbatim}
\end{multicols}

\noindent
or \emph{pattern matching}:

\begin{verbatim}
when True action = action
when False _     = pure ()
\end{verbatim}

\noindent
where \verb|_| can be read as throwing away a value.

\paragraph{Functions and operators}
Functions can be used as infix operators by surrounding them with backticks,
operators can be used as prefix functions by surrounding them with parentheses:

\begin{multicols}{2}
\begin{verbatim}
mul x y = (*) x y
\end{verbatim}
\begin{verbatim}
even x = x `mod` 2 == 0
\end{verbatim}
\end{multicols}

An operator is just a function whose name is symbolic:

\begin{verbatim}
(***) :: Int -> Int -> Int
a *** b = a * b * b * b
\end{verbatim}

\paragraph{Local bindings}
New bindings can be introduced using \emph{let} and \emph{where} expressions:

\begin{multicols}{2}
\begin{verbatim}
doubleIfEven x =
  let even y = y `mod` 2 == 0
  in if even x then x * 2 else x
\end{verbatim}
\columnbreak
\begin{verbatim}
doubleIfEven x
    | even x    = x * 2
    | otherwise = x
  where
    even y = y `mod` 2 == 0
\end{verbatim}
\end{multicols}

Unlike let expressions, where expressions are in scope for all of a function's
guards.  In do-notation, the \verb|in| is omitted:

\begin{verbatim}
monadicDoubleIfEven x = do
  let even y = y `mod` 2 == 0
  pure (if even x then x * 2 else x)
\end{verbatim}

\paragraph{Language extensions}
GHC has a large number of extensions to standard Haskell, which are not enabled
by default.  Some of these are used in this thesis.  They will be explained as
they are first used.
