In this chapter we present and evaluate CoCo, our tool for finding
properties of equivalence and refinement between concurrent Haskell
expressions with shared state.  We first discuss some key concerns in
the implementation of a tool like this~\sref{coco-concerns}, and then
demonstrate the use of the tool with an illustrative
example~\sref{coco-example}.  We explain how properties are
discovered~\sref{coco-hiw} and argue the correctness of our
approach~\sref{coco-correctness}.  We then present two further
examples~\sref{coco-cases}.  Next we discuss how CoCo properties can
be incorporated into a \dejafu{} testsuite.  Finally, we present
conclusions and evaluate the approach~\sref{coco-conclusions}.

This chapter is derived from our previous work \todo{cite when
  published}.

\section{Key Concerns of Observing Concurrent Programs}
\label{sec:coco-concerns}

In implementing a tool to discover properties of \emph{concurrent}
programs, we have some concerns which are not applicable to sequential
programs.  Firstly, concurrent programs are nondeterministic; so if we
simply compared results of single executions, the discovered
properties may not hold in the general case.  Secondly, mutable state
is subject to interference from other threads; so if we do not
consider concurrent interference, the discovered properties may not
hold when there are more threads involved.  Finally, we need to decide
what it means for two concurrent programs to be related.

\paragraph{Nondeterminism}
If we restrict the nondeterminism in our program to schedule
nondeterminism, we can use systematic concurrency testing
(SCT)\cite{coons2013,musuvathi2008,musuvathi2007,flanagan2005}
techniques as implemented in \dejafu{} to produce the set of results
of a generated program fragment.

\paragraph{Interference}
We do not know what sort of interference may lead to interesting
results.  So CoCo requires the programmer to supply a function with
effects, which is executed concurrently during property discovery, to
provide this interference.  By supplying different sorts of
interference, the programmer can see how the functions under test
behave in different concurrent contexts.

\paragraph{Properties}
We formulate our properties in terms of \emph{observational
  refinement}\cite{he1986}, where the observations we take are
snapshots of the state.  CoCo requires the programmer to supply an
observation function to produce these snapshots.  By varying their
observation function, the programmer can see different aspects of the
functions under test.

We define a \emph{behaviour} of a concurrent program as a pair of a
final observation, taken after the program terminates, and a possible
failure.  By considering the set of a program's possible behaviours,
rather than simply final observations, we can distinguish between
operations which may fail and those which do not.  Properties that we
report are of the form \verb|A === B|, meaning that the sets of
behaviours of \verb|A| and \verb|B| are equal; and \verb|A ->- B|,
meaning that the set of behaviours of \verb|A| is a strict subset of
the set of behaviours of \verb|B|.

\section{An Illustrative Example}
\label{sec:coco-example}

Let us now show an example use of CoCo for Haskell \verb|MVar|s.
Recall that an \verb|MVar| is a mutable memory cell which may be
\emph{full} or \emph{empty}.  We now examine three basic operations
over \verb|MVar|s: put, take, and read.  To \emph{put} is to block
until the \verb|MVar| is empty and then set its value.  To \emph{take}
is to block until the \verb|MVar| is full, remove its value, and
return the value.  To \emph{read} is to \emph{take}, but without
emptying the \verb|MVar|.

\begin{listing}
\centering
\begin{cminted}{haskell}
putMVar  :: MVar Concurrency Int -> Int -> Concurrency ()
takeMVar :: MVar Concurrency Int -> Concurrency Int
readMVar :: MVar Concurrency Int -> Concurrency Int
\end{cminted}
\caption{Type signatures for \texttt{MVar} operations in CoCo.}\label{lst:mvar_types}
\end{listing}

Allowing shared values of type \verb|Int|, we obtain the type
signatures in \cref{lst:mvar_types}.  Here \verb|Concurrency| is an
implementation of the \verb|MonadConc| typeclass, provided by CoCo.
The \verb|MVar| type is an abstract type defined in \verb|MonadConc|,
with the concrete type determined by the monad used.  In this case the
concrete type is defined as part of \dejafu{}.

\begin{listing}
\centering
\begin{cminted}{haskell}
type C = Concurrency

sig :: Sig (MVar C Int) (Maybe Int) (Maybe Int)
sig = Sig
  { initialise  = maybe newEmptyMVar newMVar
  , expressions =
    [ -- example 1
      lit "putMVar"  (putMVar  :: MVar C Int -> Int -> C ())
    , lit "takeMVar" (takeMVar :: MVar C Int -> C Int)
    , lit "readMVar" (readMVar :: MVar C Int -> C Int)
    ]
  , backgroundExpressions =
    [ -- example 2
      lit "tryPutMVar" (tryPutMVar :: MVar C Int -> Int -> C Bool)
    ]
  , interfere  = \v _ -> putMVar v 42
  , observe    = \v _ -> tryReadMVar v
  , backToSeed = \v _ -> tryReadMVar v
  }
\end{cminted}
\caption{CoCo signature for \texttt{MVar}s holding \texttt{Int}s.}\label{lst:mvar}
\end{listing}

\paragraph{Signatures}
When we use CoCo, we must provide the functions and values which may
appear in properties.  We must also provide a way to initialise the
state, an observation function, and an interference function.  We call
this collection of programmer-supplied definitions the
\emph{signature}.  \Cref{lst:mvar} shows a signature for \verb|MVar|
operations.  The initialisation function constructs an empty or a full
\verb|MVar|.  The interference function simply stores a new value.
The observation function takes a snapshot of the state.  The
\verb|backToSeed| function is used to check whether the state has been
changed: if the original and final seed values are the same, the state
is unchanged.

It is essential to provide an initialisation function which gives a
representative collection of states, and an interference function
which can disrupt the functions of interest.  If our initialisation
function only produced a full \verb|MVar|, we could find properties
which do not hold when the \verb|MVar| is empty.  Because our
interference function only writes to the \verb|MVar|, we may find
properties which do not hold when there are multiple consumers.
Developing a fuller understanding of the functions under test may
require examining the different property-sets found under different
execution conditions.

\paragraph{Discovering properties}
\Cref{lst:mvar_props1} shows the properties which CoCo discovers given
\verb|putMVar|, \verb|takeMVar|, and \verb|readMVar|.  In this output,
\verb|@| is the state argument, which is the \verb|MVar|.  For
convenience of reference, we have added numbers to the CoCo
properties.  These numbers are not included in the normal output of
the tool.


\begin{listing}
\centering
\begin{cminted}{text}
(1)   readMVar @  ===  readMVar @ >> readMVar @
(2)   readMVar @  ->-  takeMVar @ >>= \x -> putMVar @ x
(3)   takeMVar @  ===  readMVar @ >> takeMVar @
(4)  putMVar @ x  ===  putMVar @ x >> readMVar @
\end{cminted}
\caption{CoCo-discovered properties about \texttt{MVar}s.}\label{lst:mvar_props1}
\end{listing}

Property (1) shows that \verb|readMVar| is idempotent; (2) shows that
it is not merely a take followed by a put, it is rather a distinct
operation; (3) and (4) show that it does not modify the \verb|MVar|.
We see the effect of the interference in (2): with no other producers,
this would be an equivalence; it is only when interference by another
thread is introduced that the equivalence breaks down and the
distinction is revealed.

\paragraph{Background expressions}
Sometimes when expressing properties it is necessary to call upon
other expressions which are of secondary interest.  Such expressions
are commonly called \emph{background} expressions.  A property is only
reported if each side includes at least one non-background expression.

\begin{listing}
\centering
\begin{cminted}{text}
      readMVar @  ===  readMVar @ >> tryPutMVar @ x
(5)   readMVar @  ===  readMVar @ >>= \x -> tryPutMVar @ x
      readMVar @  ->-  takeMVar @ >>= \x -> tryPutMVar @ x
     putMVar @ x  ===  putMVar @ x >> tryPutMVar @ x1
\end{cminted}
\caption{Additional CoCo-discovered properties about \texttt{MVar}s.}\label{lst:mvar_props2}
\end{listing}

If we include \verb|tryPutMVar|, a non-blocking version of
\verb|putMVar|, as a background expression, CoCo discovers the
additional properties in \cref{lst:mvar_props2}.  Property (5) shows
how important the choice of interference function is.  The left and
right terms are not equivalent.  If the interference were to empty a
full \verb|MVar| then the right term could restore its original value.
As our choice of interference function only produces, rather than
consumes, it will never alter the value in a full \verb|MVar|.

The example in this section takes about 1.5 seconds to run, and the
output displayed here is the output of the tool, aside from the
property numbers.

\section{How CoCo Works}
\label{sec:coco-hiw}

A simplified version of our approach is to generate all terms up to
some syntactic size limit, compute and store their behaviours, and
then find properties by comparing the sets of behaviours of each pair
of terms.  This would be slow, however.  Following the lead of
QuickSpec\cite{smallbone2017,claessen2010} we make three key
improvements:

\begin{enumerate}
\item We generate \emph{schemas} with \emph{holes}, rather than
  \emph{terms} with \emph{variables}.
\item We only compute the set of behaviours of the most general term
  of every schema.
\item We interleave property discovery with schema generation, and
  aggressively prune redundant schemas.
\end{enumerate}

The main difference between our approach and QuickSpec is how we
handle monadic operations, and that QuickSpec compares \emph{equality}
of term \emph{results} whereas we compare \emph{refinement} of term
\emph{behaviours}.  Furthermore, we generate lambda-terms in a
restricted setting whereas QuickSpec does not do so at all.

\subsection{Representing and Generating Expression Schemas}
\label{sec:coco-hiw-gen}

We can greatly reduce the number of expressions considered by not
generating alpha-equivalent ones.  Instead of generating an expression
like \verb|push @ x >> push @ y|, we will instead generate the
expression \verb|push @ ? >> push @ ?| where each \verb|?| is a
\emph{hole} for a variable.  These expressions-with-holes are called
\emph{schemas}.  One schema can be instantiated into many \emph{terms}
by assigning variable names to groups of holes.  The push-push schema
has two semantically distinct term instances: the single-variable and
the two-variable cases.

\begin{listing}
\centering
\begin{cminted}{haskell}
data Expr s h
  = Lit  String Dynamic
  | Var  TypeRep (Var h)
  | Bind TypeRep (Expr s h) (Expr s h)
  | Ap   TypeRep (Expr s h) (Expr s h)
  | State

data Var h = Hole h | Named String | Bound Int

type Schema s = Expr s ()
type Term   s = Expr s Void
\end{cminted}
\caption{Representation of Haskell expressions.}
\label{lst:exprrep}
\end{listing}

Our expression representation is shown in \cref{lst:exprrep}.  The
\verb|Expr| type is parameterised by the state type and a \emph{hole}
type.  The state parameter ensures expressions that assume different
execution contexts cannot be inadvertently combined.  The hole
parameter allows for a statically enforced distinction between schemas
and terms.  Each \verb|Expr| constructor carries around a type (except
the state, which is implicit).  In most of the implementation we hide
the details of this representation and instead provide \emph{smart
  constructor} functions to ensure only well-typed expressions can be
constructed.

\paragraph{Schema generation}
Generating new schemas is straightforward.  We give expressions a
notion of \emph{size}, corresponding roughly to the size of the
\verb|Expr| tree.  Schemas are generated in size order.  The needed
expressions of size 1 are supplied in the user's signature.  For
larger sizes we combine appropriately sized pairings of already
generated schemas and keep the type-correct ones.

We interleave generation with evaluation and property discovery.  In
this way we can partition schemas into equivalence classes and use
only the smallest of known-equivalent schemas when generating new
ones.  We do this for both pure and monadic schemas.

\paragraph{Monadic expressions}
The expressions of most interest to us are \emph{monadic} expressions.
Such expressions allow us to combine smaller effects to create larger
ones.  We simplify this task by taking inspiration from Haskell's
do-notation, a syntactic sugar for expressing sequences of monadic
operations in an imperative style, which has explicit variable
bindings and makes the sequencing of effects clear.  Rather than
generating lambda-terms, we use a kind of first-class do-notation
where the monadic bind operation binds the result of evaluating the
\emph{binder} to zero or more holes in the \emph{body}.  Restricting
ourselves to this simpler case allows us to avoid many of the
complexities of trying to generate lambda-terms directly.

For example, the generation of the schema
\verb|pop @ >>= \x -> push @ x| proceeds as follows:

\begin{enumerate}
\item Combine \verb|pop| and \verb|@| to produce \verb|pop @|
\item Combine \verb|push| and \verb|@| to produce \verb|push @|
\item Combine \verb|push @| and \verb|?| to produce \verb|push @ ?|
\item Combine \verb|pop @| and \verb|push @ ?| to produce both
  \verb|pop @ >> push @ ?| and \verb|pop @ >>= \x -> push @ x|.
\end{enumerate}

To avoid name clashes, bound variables use de Bruijn
indices\cite{debruijn1972}.  Names are only assigned when expressions
are displayed to the user.

\subsection{Evaluating Most General Terms}
\label{sec:coco-hiw-eval}

Time spent evaluating terms dominates the execution cost of CoCo.  In
the worst case the number of executions needed for a term is
exponential in the number of threads, pre-emptive context switches,
and blocking operations\cite{musuvathi2007}.

What is more, our term evaluation always involves at least two
threads: the term thread executing the term itself, and an
\emph{interference thread}.  The term thread may fork additional
threads.  The interference thread is essential to distinguish
refinement from equality in some cases.  For example, the equivalence
in \cref{lst:prop_mvar3} holds only when is no concurrent producer for
the same \verb|MVar|.

\begin{listing}
\centering
\begin{cminted}{text}
readMVar @  ===  takeMVar @ >>= \x -> putMVar @ x
\end{cminted}
\caption{A property that holds with no interference.}\label{lst:prop_mvar3}
\end{listing}

To avoid repeated work, we compute the behaviours of all the terms for
a schema when it is generated.  We annotate each schema with some
metadata, including its behaviour-sets, and compare these cached
behaviours later when discovering properties.  While possibly a
significant space cost, storing this data reduces the execution time
of some of our test applications from hours to minutes.  We discuss
this further in \cref{sec:coco-conclusions}.

\paragraph{Deriving terms from schemas}
One schema may have many term instances.  \Cref{lst:schematerms} shows
an example of a schema with two holes of one type and two of another.
From this, we can produce four semantically distinct terms.  We can
order the terms by number of distinct variables.  The term with the
most variables is the \emph{most general term}.

\begin{listing}
\centering
\begin{cminted}{text}
f (? :: Int) (? :: Bool) (? :: Bool) (? :: Int)

f (w :: Int) (x :: Bool) (y :: Bool) (z :: Int)
f (w :: Int) (x :: Bool) (y :: Bool) (w :: Int)
f (w :: Int) (x :: Bool) (x :: Bool) (z :: Int)
f (w :: Int) (x :: Bool) (x :: Bool) (w :: Int)
\end{cminted}
\caption{A schema and its term instances.}\label{lst:schematerms}
\end{listing}

We use a simple reduce-and-conquer algorithm to eliminate holes one
type at a time:

\begin{enumerate}
\item Pick a type.  Find the set of all holes of that type, each
  represented by its position in the \verb|Expr| tree.
\item For each partition of the hole-set make a distinct copy of the
  schema and in each case assign to each subset in the partition a
  distinct variable name.
\item If there are remaining hole types, continue recursively from
  (1).
\item Finally, sort the terms by number of distinct variables.
\end{enumerate}

\paragraph{Evaluating terms}
To compute the behaviours of every term for a schema, we need only
consider the most general term.  The behaviours of all less-general
terms can be derived from the most general case by restricting to
cases where the variables are equal.  For example, given the
behaviours of the term \verb|f x y|, we throw away those where
\verb|x| $\neq$ \verb|y| to obtain the behaviours of the term
\verb|f x x|.

\dejafu{} allows us to make an observation of the final state even if
evaluation of the term deadlocks.  This is essential, as an operation
which deadlocks may have altered the state before blocking.

\subsection{Property Discovery and Schema Pruning}
\label{sec:coco-hiw-prune}

Not only do we interleave generation with evaluation, we also
interleave it with property-discovery.  After all schemas of a given
size are generated and their most general terms evaluated, we compare
each such new schema against all smaller ones to discover equivalences
and refinements.

As one schema may correspond to many terms, we may discover many
properties between a pair of schemas.  In practice, most of these
properties are consequences of more general ones.  We solve this
problem by first producing all properties between the pair of schemas,
and then pruning properties which are simple consequences of another.
Property $P_2$ is made redundant by property $P_1$ if (1) both $P_1$
and $P_2$ are equivalences or both are refinements; and (2) $P_1$ has
a more general allocation of variables to holes.

\paragraph{Smallest schemas}
To avoid discovering the same property multiple times, we maintain a
set of \emph{smallest schemas}.  At first, all schemas are assumed to
be smallest.  If a syntactically smaller schema is a refinement of a
larger one, the larger is annotated as ``not smallest''.  When
generating new monadic binds:

\begin{itemize}
\item A schema \verb|S >> T| is only generated if both \verb|S| and
  \verb|T| are smallest schemas.
\item A schema \verb|S >>= \x -> T[x]| is only generated if \verb|T|
  is a smallest schema.
\end{itemize}

We also only consider properties \verb|S === T| or \verb|S ->- T|
where both \verb|S| and \verb|T| are smallest schemas.

\paragraph{Neutral schemas}
A schema \verb|N| is neutral if and only if, for all other schemas
\verb|S|, these identities hold: \verb|N >> S === S === S >> N|.  For
example, \verb|readMVar| is not a neutral \verb|MVar| operation, as it
may block, but the non-blocking alternative \verb|tryReadMVar| is
neutral.  A sufficient condition for a schema to be neutral is if its
most general term instance is (1)~always atomic; (2)~never fails; and
(3)~never modifies the state.

We use a heuristic method based on execution traces to determine if a
schema is atomic, and use the seed values to determine if it modifies
the state.  If a schema is judged to be neutral, we do not use it when
constructing larger schemas.

\paragraph{Projection to a common namespace}
We compute the behaviours of every term individually, yet we construct
properties from pairs of terms.  Each term introduces its own variable
namespace: the variable ``x'' in one term is unrelated to the variable
``x'' in another.  When discovering properties, we must first project
both terms into a common namespace.  Each variable in each term can
either be given a unique name, or identified with a variable in the
other term.  We never reduce the number of distinct variables in a
term.  To do so would only reproduce another term generated from the
same schema.

As a pair of terms may have many projections, we may discover many
properties between them: at most one for each projection.  In
practice, most of these properties are consequences of more general
ones.  We only keep the most general.

\section{Soundness and Completeness}
\label{sec:coco-correctness}

Correctness for CoCo states that only true properties are reported,
and that all true properties where the terms involved fit into the
size bound are reported.  As with \dejafu{}, we do not concern
ourselves here with the formal correctness of the CoCo implementation.

\paragraph{Soundness}
There are two potential sources of unsoundness in CoCo.  Firstly,
properties are only checked for a finite number of cases; and secondly
\dejafu{} is used to find the possible results of a term, which is
incomplete by default.

We can increase confidence in the correctness of CoCo properties by
increasing the number of test cases, but the fundamental problem
remains.  CoCo is not a model checker, and it is always possible that
the next input tried after we ceased testing would have been a
counterexample.  For finite types, however, we can consider all
inputs.

The incompleteness of \dejafu{} can be solved with additional time.
\dejafu{} offers a complete mode.  CoCo does not use it because it is
typically slower than the incomplete testing, but as the terms we
generate are small this may not be a problem in practice.  CoCo could
be changed to use the complete testing, which would ensure that all
possible behaviours of a term, for each set of inputs considered, are
found.

\paragraph{Completeness}
If we assume that CoCo is sound (and so never incorrectly says a
property is true or false), there are two remaining potential sources
of incompleteness.  Firstly, some schemas are discarded when
generating new ones; and secondly, properties are thrown away which
are judged to be consequences of another.

A property between two terms cannot be discovered if either term is
simply not generated.  When generating new schemas, CoCo tries all
appropriately sized pairings of previously generated schemas and keeps
the type-correct ones.  If our type checker is incorrect, then valid
schemas may be thrown away.  Currently we do not support class
polymorphism at all, so terms which are only well-typed due to
typeclass use will be discarded.

We do not require CoCo to report properties which are implied by
another.  As many terms correspond to the same schema, and many
projections correspond to the same pair of terms, in general there
will be many such redundant properties.  We use a simple syntactic
criteria to determine whether one property implies another, rather
than attempting any logical analysis.

\section{Case Studies}
\label{sec:coco-cases}

We now discuss two case studies of using CoCo.

\subsection{Concurrent Stacks}
\label{sec:coco-cases-stack}

\begin{listing}
\centering
\begin{cminted}{haskell}
newtype LockStack m a = LockStack (MVar m [a])

push :: MonadConc m => a -> LockStack m a -> m ()
push a (LockStack v) = modifyMVar v (\as -> pure (a:as, ()))

pop :: MonadConc m => LockStack m a -> m (Maybe a)
pop (LockStack v) = modifyMVar v (\as -> (drop 1 as, listToMaybe as))

peek :: MonadConc m => LockStack m a -> m (Maybe a)
peek (LockStack v) = fmap listToMaybe (readMVar v)
\end{cminted}
\caption{A lock-based mutable stack.}\label{lst:lockstack}
\end{listing}

\paragraph{Lock-based stacks}
Mutable stacks are commonly used for synchronisation amongst multiple
threads.  A simple mutable stack is just an immutable list inside an
\verb|MVar| shared variable, as in \cref{lst:lockstack}.

\begin{listing}
\centering
\begin{cminted}{text}
(6)  peek @  ->-  push x @ >> pop @
(7)  peek @  ->-  (push x @) ||| (pop @)
(8)  peek @  ->-  pop @ >>= \m -> whenJust push @ m
\end{cminted}
\caption{CoCo-discovered properties about the \texttt{MVar} stack.}\label{lst:lockstack2}
\end{listing}

With this signature, CoCo discovers the properties in
\cref{lst:lockstack2}, where the initialisation function constructs a
stack from a list, the observation function converts it back to a
list, and the interference function sets the contents of the stack to
a given list.  Here \verb#|||# is concurrent composition.  Property
(6) may seem surprising: the left term returns the top of stack
whereas the right term returns the value pushed.  Remember that CoCo
does not consider equality of results when determining properties,
only the effect on the state.  Property (7) is a consequence of (6).
Property (8) is analogous to the \verb|readMVar| properties presented
in \cref{sec:coco-example}, as we might expect given how the stack
operations are defined.

\paragraph{Buggy functions}
Suppose we add an \emph{incorrect} \verb|push2| function, which is
meant to push two values atomically, but which only pushes the second
value twice.

\begin{listing}
\centering
\begin{cminted}{text}
push2 x1 x @  ->-  push x @ >> push x @
\end{cminted}
\caption{A property about an incorrect function.}\label{lst:lockstack3}
\end{listing}

CoCo finds the property in \cref{lst:lockstack3}.  As this is a strict
refinement, we now know that \verb|push2| is more deterministic in
some way than two \verb|push|es.  As we know that the composition of
two \verb|push|es is not atomic, this strongly suggests that
\verb|push2| is.  We can also see the effect of \verb|push2| on the
state, and that it is incorrect!

\paragraph{Choice of observation}
As CoCo uses a programmer-supplied observation function in its
property-discovery process, the programmer can supply different
observations to discover different properties.  By changing the
observation of our stack from list equality to \verb|peek|, we
discover a new collection of properties, shown in
\cref{lst:lockstack4}.  Here we have fixed the \verb|push2| function
to behave correctly and also removed \verb#|||# from the signature.
Properties (9) and (10) show the power of supplying a custom
observation function: in the left and right terms, the stack states
are \emph{not} equal.  In both (9) and (10) the left term increases
the stack depth by one, and the right by two.  We now see that
\verb|push2| leaves its second argument on the top of the stack.  We
could not directly observe this before, as a single push would leave
the stack sizes out of balance.  Throwing away unnecessary details, in
this case the tail of the stack, allows us to see more than we
previously could.

\begin{listing}
\centering
\begin{cminted}{text}
           peek @  ->-  push x @ >> pop @
           peek @  ===  pop @ >>= \m -> whenJust push @ m
         push x @  ===  pop @ >> push x @
(9)     push x1 @  ===  push2 x x1 @
(10)    push x1 @  ===  push x @ >> push x1 @
whenJust push @ m  ===  whenJust (push2 x) @ m
\end{cminted}
\caption{Changing the observation changes the properties.}\label{lst:lockstack4}
\end{listing}

It is important to bear in mind that there is no \emph{best}
observation to make, no \emph{best} interference to consider, and no
\emph{best} set of properties to discover.  Each choice of observation
and interference will reveal something about the functions under test.
By considering different cases, we can arrive at a fuller
understanding of our code.

\paragraph{Choice of implementation}
Due to their blocking behaviour, \verb|MVar|s can have poor
performance under contention.  An alternative concurrency primitive is
the \verb|CRef|.  An atomic compare-and-swap operation updates
\verb|CRef| values efficiently even with contention.
\Cref{lst:crefstack} shows our implementation, which is similar to the
\verb|MVar| stack.

\begin{listing}
\centering
\begin{cminted}{haskell}
newtype CASStack m a = CASStack (CRef m [a])

push :: MonadConc m => a -> CASStack m a -> m ()
push a (CASStack r) = modifyCRefCAS r (\as -> (a:as, ()))

pop :: MonadConc m => CASStack m a -> m (Maybe a)
pop (CASStack r) = modifyCRefCAS r (\as -> (drop 1 as, listToMaybe as))

peek :: MonadConc m => CASStack m a -> m (Maybe a)
peek (CASStack r) = fmap listToMaybe (readCRef r)
\end{cminted}
\caption{A lock-free mutable stack.}
\label{lst:crefstack}
\end{listing}

A feature of CoCo that differentiates it from other property-discovery
tools is the ability to compare two different signatures which have
compatible observation types.  We can compare the \verb|MVar| and
\verb|CRef| stacks by simply supplying both signatures to the tool,
which then reports, amongst others, the correspondences in
\cref{lst:stacks}.  Here we use the list observation again.  Functions
with names ending \verb|M| are for \verb|MVar| stacks, functions with
names ending \verb|C| for \verb|CRef| stacks.  These properties tell
us what we want to know: the \verb|CRef| stack is equivalent to the
\verb|MVar| stack.

\begin{listing}
\centering
\begin{cminted}{text}
   popM @  ===  popC @
  peekM @  ===  peekC @
pushM x @  ===  pushC x @
\end{cminted}
\caption{Discovering properties between signatures.}\label{lst:stacks}
\end{listing}

A common approach when first writing a program is to do everything in
a simple and clearly correct fashion.  After checking correctness, we
may gradually rewrite components to meet performance requirements.  At
which point testing must establish that the rewritten components
preserve the behaviour.  The ability to determine observational
equivalence of different implementations of the same API is an
alternative to the more-common unit-testing for this
task\cite{he1986}.

\subsection{Semaphores}
\label{sec:coco-cases-semaphore}

A semaphore is a synchronisation primitive used to regulate access to
some resource.  A semaphore can be thought of as a record of how many
units of some abstract resource are available, with operations to
adjust the record in a race-free way.  \emph{Binary semaphores} only
have two states, and are used to implement locks. \emph{Counting
  semaphores} have an arbitrary number of states.  An implementation
of counting semaphores is provided in the Control.Concurrent.QSemN
library module.  As with the \verb|MVar| and \verb|CRef|, \dejafu{}
provides a typeclass-generalised version which we use here.

\begin{listing}
\centering
\begin{cminted}{haskell}
type C = Concurrency

sig :: Sig (QSemN C) Int Int
sig = Sig
  { initialState = new . abs
  , expressions =
    [ lit "wait"   (wait   :: QSemN C -> Int -> C ())
    , lit "signal" (signal :: QSemN C -> Int -> C ())
    ]
  , backgroundExpressions =
    [ commLit "|||" ((|||) :: C A -> C B -> C ())
    , commLit "+"   ((+)   :: Int -> Int -> Int)
    , lit "-"       ((-)   :: Int -> Int -> Int)
    , lit "0" (0 :: Int)
    , lit "1" (1 :: Int)
    ]
  , observation = \q _ -> remaining q
  , backToSeed  = \q _ -> remaining q
  , setState = \q n -> let i = n `div` 2 in wait q i >> signal q i
  }
\end{cminted}
\caption{CoCo signature for the QSemN type.}
\label{lst:sig}
\end{listing}

\Cref{lst:sig} shows the signature we provide to CoCo.  CoCo supports
polymorphic function types, as can be seen in the type of \verb#|||#,
where \verb|A| and \verb|B| are types we use as type \emph{variables}.
The \verb|commLit| function indicates that the supplied binary
function is \emph{commutative}, which is used to prune the generated
schemas further.  The \verb|new|, \verb|wait|, \verb|signal|, and
\verb|remaining| functions are provided by the \verb|QSemN| library
module.  We construct a new semaphore by allocating an arbitrary
amount of resource; we observe how much resource remains; and we
interfere by taking and then replacing half of the resource.  The
interference thread is interleaved with the term thread, so it may
cause the term thread to block.

CoCo finds many properties in this example, so in the remainder of the
subsection we only discuss selected properties.

\paragraph{Waiting and signalling}
CoCo tells us in properties (11) and (12) that the effect of waiting
for zero resource and of signalling the availability of zero resource
are the same --- neither affects the state of the semaphore.
Additionally, property (11) shows that waiting for zero resource is
not a neutral operation, as if it were CoCo would prune the property
away.  This suggests that \verb|wait| may block.

\begin{listing}
\centering
\begin{cminted}{text}
(11)          wait @ 0  ===  wait @ 0 >> wait @ 0
(12)        signal @ 0  ===  wait @ 0 >> wait @ 0
(13)        signal @ 1  ===  wait @ (0 - 1)
(14)  signal @ (1 + 1)  ===  wait @ (0 - (1 + 1))
(15)  signal @ (abs x)  ===  wait @ (negate (abs x))
\end{cminted}
\caption{Properties about semaphore waiting and signalling.}\label{lst:sem2}
\end{listing}

CoCo also finds properties (13) and (14), revealing another
implementation detail which is not strictly guaranteed by the abstract
definition of a semaphore.  If we extend our signature with \verb|abs|
and \verb|negate|, a more general property (15), that signalling a
positive resource \verb|n| appears to be equivalent to \emph{waiting
  for a negative resource} \verb|-n|, is found.

\paragraph{A lack of composability}
CoCo reports a strict refinement, property (16), involving
\verb|signal| and \verb|wait|, which we might expect to be an
equivalence.  The only interference we have specified may occur is
taking and then returning half of the original resource.  So surely
releasing a quantity of resource and then claiming it again should be
fine?

\begin{listing}
\centering
\begin{cminted}{text}
(16)         signal @ 0  ->-  signal @ x >> wait @ x
(17)  signal @ (x + x1)  ->-  signal @ x >> signal @ x1
(18)  signal @ (x + x1)  ->-  (signal @ x) ||| (signal @ x1)
\end{cminted}
\caption{Properties suggesting a lack of composability.}\label{lst:sem3}
\end{listing}

We also get two properties, (17) and (18), solely about \verb|signal|.
Surely signaling the availability of a sum is the same as signaling
the availability of its constituent parts?  As we are about to see, it
is due to negative values that these are only refinements.

\paragraph{Types}
Signalling or awaiting a negative quantity is a breach of the
semaphore protocol.  Perhaps a better interface for semaphores would
only allow nonnegative quantities.  The change might avoid accidental
breakage in the future if the semantics of negative values are
unwittingly changed.

CoCo supports many types, but not all.  If the programmer wishes to
use types outside of the built-in collection, they must provide some
information: a way to enumerate values, an equality predicate, and a
symbol to use in variable names.  In this way, the programmer can
extend CoCo to work with arbitrary types, or alter the behaviour of
existing types.

If we alter the signature so that \verb|signal| and \verb|wait| use
the type of natural numbers rather than integers, properties (16--18)
become equivalences, as shown in \cref{lst:sem4}

\begin{listing}
\centering
\begin{cminted}{text}
       signal @ 0  ===  signal @ n >> wait @ n
signal @ (n + n1)  ===  signal @ n >> signal @ n1
signal @ (n + n1)  ===  (signal @ n) ||| (signal @ n1)
\end{cminted}
\caption{Properties (16--18) restricted to natural numbers.}\label{lst:sem4}
\end{listing}

We could pursue this issue further by examining the terms with
\dejafu{} when given a negative quantity, or we could change the type
of the function to forbid that case.  Ideally, illegal states should
be unrepresentable.

\section{Using CoCo Properties in \dejafu{}}
\label{sec:coco-dejafu}

The CoCo output is not syntactically valid Haskell.  \texttt{@} is not
a legal identifier, and the signatures are implicit.  So properties
cannot simply be copied into a testsuite.

\paragraph{Pretty-printing}
CoCo properties are represented as a pair of expressions and the
operator (equality or strict refinement) connecting them.  The visual
form of the operators is hard-coded, but how the expressions are
displayed is controlled by a pretty-printer.  There is a default
pretty-printer, used throughout this chapter, which favours a concise
output.  There is also the option to produce \dejafu{}-compatible
output, giving properties which can be checked by \dejafu{} directly,
or by the \package{hunit-dejafu} and \package{tasty-dejafu} packages.

\begin{listing}
  \centering
  \begin{cminted}{haskell}
-- default, not valid Haskell
readMVar @  ===  readMVar @ >> readMVar @

-- dejafu
check $ sigL (\h0 -> readMVar h0) === sigL (\h0 -> readMVar h0 >> readMVar h0)

-- hunit/tasty
testProperty "name" $
  sigL (\h0 -> readMVar h0) === sigL (\h0 -> readMVar h0 >> readMVar h0)
  \end{cminted}
  \caption{The different CoCo pretty-printing modes.}\label{lst:coco_ppr}
\end{listing}

\Cref{lst:coco_ppr} shows the three pretty-printing modes.  The
``dejafu'' and ``hunit/tasty'' modes are valid Haskell, and can be
used as a regression test to ensure the property holds (after
supplying a signature).  These two alternative views of properties are
more verbose, and so less convenient to read than the default output
when examining a list of properties.  Furthermore, it is little work
to transform a CoCo property into a form checkable by \dejafu{}.

\paragraph{Signatures}
\dejafu{} has a notion of signatures, similar to CoCo signatures.  A
\dejafu{} signature is a simplified form of a CoCo signature: it has
an initialisation function, an observation function, an interference
function, and a single expression to evaluate.  \Cref{lst:coco_ppr}
uses signature functions, which take the expression and produce a
signature.  These functions are called \texttt{sigL} because the
general form of a CoCo invocation provides two signatures to compare,
discovering properties of a single signature is a special case of
this.  So these properties use the ``left signature'', if two
signatures were being compared, there would also be reference to a
\texttt{sigR} (the ``right signature'').

CoCo provides a function, \texttt{cocoToDejaFu}, to convert a CoCo
signature into a \dejafu{} signature function.

\paragraph{Checking properties}
\dejafu{} can check properties, and also produce a list of
counterexamples for failing properties.  Properties are evaluated in
the same way as CoCo: the behaviours of each term are found with
\dejafu{}'s systematic concurrency testing functionality, and then
these sets of behaviours are compared to check if the property holds.
By default, properties are checked with more variable-assignments than
CoCo, to increase confidence in the result.  The user can also specify
the number of seed values and variable-assignments to try, to have
even more confidence.

In general it is faster for \dejafu{} to check a property than for
CoCo to find it, as to find a property with terms of size $n$ and $m$,
CoCo must first generate and evaluate many expressions smaller than
$n$ and $m$.  \dejafu{} just needs to evaluate the two terms in the
property.

Similarly to typical property-testing tools like
QuickCheck\cite{claessen2000}, \dejafu{} uses typeclass polymorphism
to enable testing properties which take arguments.  If \texttt{f x} is
testable, and \texttt{x} is of some type which can be enumerated by
LeanCheck, then \verb|\x -> f x| is testable.

\section{Evaluation and Conclusions}
\label{sec:coco-conclusions}

Our aim is to help programmers overcome the difficulty of testing
concurrent programs.  To work towards this, we have presented a new
tool, CoCo, to discover behavioural properties of effectful functions
operating on shared state.

\paragraph{Applicability beyond Haskell}
CoCo is tied to Haskell in two ways: it has some knowledge of Haskell
types, which is used when generating expressions; and it relies on the
\dejafu{} tool to find the results of executing an expression.
However, it could be reimplemented for another language.  For example,
in Erlang the objects of interest are processes.  Initialisation is to
create a process in a known state.  Observation is to send a request
for information to a process.  Interference is to send messages to a
process to change its internal state.  The \textsc{Pulse} tool for
systematically testing Erlang programs\cite{claessen2009} would play
the part of \dejafu{}.

\paragraph{Value of reported properties}
Although only supported by a finite number of test cases, the
properties reported by CoCo are surprisingly accurate in practice.
These properties can provide helpful insights into the behaviour of
functions.  As demonstrated in the semaphore case study, surprising
properties can suggest that implementations of some functions rely on
unstated assumptions.  It can be difficult to read concurrent source
code and grasp all its consequences.

\paragraph{Ease of use}
Ideally, a testing tool should not force the programmer to structure
their code in a specific way.  CoCo requires the use of the
concurrency typeclass used by \dejafu{}, which is not widespread in
practice.  However, it has been our experience that porting standard
Haskell code to the necessary abstraction is a type-directed and
mechanical process, requiring little insight.

\paragraph{Scaling}
While a na\"{\i}ve CoCo would scale poorly, our optimisations greatly
improve matters in both execution time and maximum resident memory
usage.  \Cref{tbl:coco_scale} shows how the three examples we have
seen perform with the optimisations disabled.  All optimisations are
on by default.  The most significant improvement by far is
\textbf{O4}, caching of term behaviours, but the other optimisations
all play their part as well.  Furthermore, \dejafu{} implements its
own optimisations which reduce the time to discover all behaviours of
a term.

Optimisations \textbf{O1} and \textbf{O2} aim to remove uninteresting
properties from the CoCo output.  Even though \textbf{O1} was not
motivated by performance, it reduces execution time in the stack and
semaphore examples.  This is unsurprising, as eliminating terms
reduces the amount of evaluation work to be done.  Optimisations
\textbf{O3} and \textbf{O4} were motivated by poor performance, and
are clear wins here.

Despite these optimisations, the semaphore example still takes around
15 minutes to run.  This is because CoCo does not recognise cases
where one schema is an instance of another.  \Cref{lst:redundant}
shows an example.

\begin{listing}
\centering
\begin{cminted}{text}
signal @ x
signal @ 0
signal @ 1
\end{cminted}
\caption{Redundant schemas.}\label{lst:redundant}
\end{listing}

Such schemas arise when the signature includes constants.  The ``most
general term'' optimisation does not apply here, as these are three
\emph{different} schemas, it just so happens that two of the schemas
are instances of another.  Constants in signatures are necessary as
CoCo does not synthesise preconditions.  If it did, constants could be
omitted, as any properties which require a specific value for a
parameter would be found as a precondition.  Property (11) in the
semaphore example would instead become:

\begin{listing}
\centering
\begin{cminted}{text}
x == 0  ==>  wait @ x  ===  wait @ x >> wait @ x
\end{cminted}
\caption{A property with a precondition.}\label{lst:precondition}
\end{listing}

Constants could be removed from the signature, indirectly solving the
performance problem.  In addition, discovering preconditions would
make CoCo able to find properties beyond its current reach.

\begin{table}
  \centering
  \begin{subtable}{\textwidth}
    \centering
    \begin{tabular}{lSSS} \toprule
      & {Time (s)} & {Max Residency (kB)} & {Properties} \\ \midrule
      \emph{All On}   &  1.58 & 3.710 & 8 \\
      \textbf{O1} Off &  1.54 & 3.710 & 8 \\
      \textbf{O2} Off &  1.57 & 3.792 & 9 \\
      \textbf{O3} Off &  1.60 & 3.657 & 8 \\
      \textbf{O4} Off & 26.62 & 2.114 & 8 \\
      \emph{All Off}  & 26.21 & 8.027 & 9 \\ \bottomrule
    \end{tabular}
    \caption{The \texttt{MVar} example~\sref{coco-example}}\label{tbl:coco_scale_mvar}
  \end{subtable}

  % [layout hack]: no gap between the tables otherwise
  \vspace{2.5em}

  \begin{subtable}{\textwidth}
    \centering
    \begin{tabular}{lSSS} \toprule
      & {Time (s)} & {Max Residency (MB)} & {Properties} \\ \midrule
      \emph{All On}   &   118 & 22.30 &  7 \\
      \textbf{O1} Off &   142 & 25.08 & 21 \\
      \textbf{O2} Off &   111 & 25.26 & 12 \\
      \textbf{O3} Off &   121 & 25.04 &  7 \\
      \textbf{O4} Off & 32341 & 22.71 &  7 \\
      \emph{All Off}  & 54352 & 57.31 & 29 \\ \bottomrule
    \end{tabular}
    \caption{The stack example~\sref{coco-cases}}\label{tbl:coco_scale_stack}
  \end{subtable}

  % [layout hack]: no gap between the tables otherwise
  \vspace{2.5em}

  \begin{subtable}{\textwidth}
    \centering
    \begin{tabular}{lSSS} \toprule
      & {Time (s)} & {Max Residency (MB)} & {Properties} \\ \midrule
      \emph{All On}   &    945 & 250.6 & 55 \\
      \textbf{O1} Off &    965 & 250.6 & 55 \\
      \textbf{O2} Off &    994 & 261.7 & 59 \\
      \textbf{O3} Off &    983 & 254.3 & 55 \\
      \textbf{O4} Off &  99490 & 242.6 & 55 \\
      \emph{All Off}  & 102759 & 408.7 & 59 \\ \bottomrule
    \end{tabular}
    \caption{The semaphore example~\sref{coco-cases}}\label{tbl:coco_scale_sem}
  \end{subtable}

  \raggedright \footnotesize
  \begin{description}
  \item[O1] is to exclude neutral schemas when generating larger schemas
  \item[O2] is to prune properties which are simple consequences of another
  \item[O3] is to only evaluate the most general term for each schema
  \item[O4] is to cache the behaviours of terms
  \end{description}

  \caption{How optimisations alter CoCo's scaling behaviour.}\label{tbl:coco_scale}
\end{table}
