A common approach to testing in Haskell is to give functional
properties about the code.  Property testing tools are used to
generate input values, and check that these properties hold, or
display a counterexample if they do not.  The popularity of property
testing stems from the difficulty of writing good tests.  In this
chapter we give an overview of using property testing tools.  We first
give a general introduction to specifying and using properties as
tests~\sref{property_testing-intro}, then discuss specific
tools~\sref{property_testing-tools}.  Finally, we summarise tools for
\emph{generating} properties~\sref{property_testing-gen}.

\section{Properties as Tests}
\label{sec:property_testing-intro}

Property-based testing\cite{claessen2000}, sometimes called
\emph{parameterised unit testing}, is an approach to testing where the
programmer gives general laws (or properties) which should hold for
all input values.  For example, a sort function should preserve
length.  This approach is unlike typical unit testing, which can be
thought of as checking specific pairs of input--output values.

\begin{listing}
\centering
\begin{cminted}{haskell}
prop_sort_len xs = length xs == length (sort xs)
\end{cminted}
\caption{A property asserting that sorting preserves length.}\label{lst:prop_sort_len}
\end{listing}

Often we do not want to check a property for arbitrary input values.
Perhaps we know something about how the functions we are testing are
expected to be used, or we are only interested in how they behave in a
certain case.  A simple way to enforce a precondition is to use
logical implication.  Implication is typically provided as part of the
property DSL of a tool, rather than being a normal boolean function.
This allows the tool to ensure that a desired number of generated
inputs pass the precondition.

\begin{listing}
\centering
\begin{cminted}{haskell}
prop_ord_insert1 x xs = ordered xs ==> ordered (insert x xs)
prop_ord_insert2 x    = forAll orderedList (\xs -> ordered (insert x xs))
\end{cminted}
\caption{Enforcing a precondition for a property.}\label{lst:prop_ord_insert}
\end{listing}

While implication is a useful technique, it can skew the input
distribution.  For example, the empty lists and lists of length one
are ordered, but only 50\% of lists of length two are.  An alternative
approach is to use a custom value generator.  By only generating input
values which satisfy the precondition, we can avoid skewing the
distribution, and improve our confidence that the property does hold
in general.

In the absence of a programmer-supplied generator function, input
values are generated in a type-directed process.  A tool will provide
a typeclass, typically called something like \verb|Arbitrary| or
\verb|Enumerable| or \verb|Listable|, which has functions to generate
values.  This typeclass will typically have instances for most common
types, but if a programmer wishes to have input values of other types,
they will need to supply a suitable instance.

\section{Property Testing Tools}
\label{sec:property_testing-tools}

Property-based testing tools mainly differ along two axes: the
expressiveness of the property DSL, and the strategy for generating
input values.  \Cref{tbl:proptools} summarises the differences between
several tools for Haskell.

\begingroup
\newcommand{\YY}{\CIRCLE}
\newcommand{\NN}{\Circle}
\newcommand{\YN}{\LEFTcircle}
\newcommand{\QQ}{\NN$^p$}

\begin{table}
\centering
\begin{tabular}{lccccccccccc}
&\rotatebox{90}{QuickCheck\hphantom{a}}
&\rotatebox{90}{SmartCheck}
&\rotatebox{90}{SmallCheck}
&\rotatebox{90}{Lazy SmallCheck}
&\rotatebox{90}{LeanCheck}
&\rotatebox{90}{Feat}
&\rotatebox{90}{Neat}
&\rotatebox{90}{GenCheck}
&\rotatebox{90}{Irulan}
&\rotatebox{90}{Reach}
\\ \toprule
\textbf{Input value generation}          &&&&&&&&&&\\
~~random                              &\YY&\YY&\NN&\NN&\NN&\YY&\NN&\YY&\YY&\NN\\
~~enumerative                         &\NN&\NN&\YY&\YY&\YY&\YY&\YY&\YY&\YY&\NN\\
~~mixed random \& enumerative         &\NN&\NN&\NN&\NN&\NN&\YY&\NN&\YY&\YY&\NN\\ \midrule
\textbf{Property DSL}          &&&&&&&&&&\\
~~existential                 &\NN&\NN&\YY&\YY&\YY&\QQ&\QQ&\QQ&\NN&\NN\\
~~higher order                &\YY&\YY&\YY&\YY&\YY&\QQ&\QQ&\QQ&\NN&\NN\\ \midrule
\textbf{Output}          &&&&&&&&&&\\
~~generalized counterexamples            &\NN&\YY&\NN&\YN&\NN&\NN&\NN&\NN&\NN&\NN\\
\bottomrule
\multicolumn{11}{l}{
\footnotesize
Legend:\hspace{1em}
\YY{} Yes/Good.\hspace{1em}
\NN{} No/Poor.\hspace{1em}
\YN{} Partial/Median.\hspace{1em}
$^p$ Potential support} \\
\end{tabular}
\caption[Summary of differences in Haskell property-testing tools.]{Summary of differences between property-based testing tools for Haskell.}\label{tbl:proptools}
\end{table}
\endgroup

\paragraph{Input value generation}
Inputs can either be generated randomly or enumerated.  Randomisation
is a simple technique which tends to work well in practice,
QuickCheck\cite{claessen2000} is an example of a randomised property
testing tool.  Alternatively, we may assume that there is some
enumeration likely to expose useful counterexamples.
SmallCheck\cite{runciman2008} enumerates values in size order, on the
assumption that most bugs are exhibited by simple counterexamples.  As
simple counterexamples are more useful to the programmer than large
ones, random approaches must have an additional \emph{shrinking} step,
to try and remove unnecessary complexity from counterexamples, which
enumerative approaches may not need.

\paragraph{Property DSL}
A more expressive property language complicates implementation, but
allows the programmer to say more about their tests.  Two important
types of property are \emph{existential} properties and
\emph{higher-order} properties.

Existential properties allow the programmer to assert that some input
exists which the property holds for.  Existential properties are
difficult to implement reliably in a randomised tool, such as
QuickCheck, because the nondeterminism means that the property may
sometimes pass and sometimes fail.  Existential properties are more
commonly supported by enumerative tools.

\begin{listing}
\centering
\begin{cminted}{haskell}
prop_gt_5 = exists (\x -> x > 5)
\end{cminted}
\caption{Using existential quantification in a property.}\label{lst:prop_gt_5}
\end{listing}

Higher-order properties are properties where some of the inputs are,
themselves, functions.  To test such a property requires the tool to
be able to generate functions.  Higher-order properties are invaluable
in the testing of higher-order functions.

\begin{listing}
\centering
\begin{cminted}{haskell}
prop_map_fuse xs f g = map g (map f xs) == map (g . f) xs
\end{cminted}
\caption{Using higher-order functions in a property.}\label{lst:prop_map_fuse}
\end{listing}

\paragraph{Output}
Despite not affecting the expressiveness of the tool, presenting
output clearly is essential.  This is why
QuickCheck\cite{claessen2000} shrinks counterexamples to find a local
minimum.  However, shrinking and enumeration are not the only ways to
produce small counterexamples.  Both SmartCheck\cite{pike2014} and
Lazy SmallCheck\cite{runciman2008} can generalise counter\-examples.
Generalising counterexamples directly can be more efficient than a
shrinking process as in QuickCheck\cite{pike2014}.  Furthermore, it is
often possible to produce a generalisation which is simpler than any
concrete counterexample.

\begin{listing}
\centering
\begin{cminted}{text}
> check $ \xs -> nub xs == (xs::[Int])
*** Failed! Falsifiable (after 3 tests):
[0,0]

Generalization:
x:x:_
\end{cminted}
%$
\caption{A generalised counterexample of an incorrect property.}\label{lst:gencntr}
\end{listing}

\paragraph{Beyond Haskell}
While this is a thesis using Haskell, the interest in property-based testing is
wider than that.

\begin{itemize}
\item QuviQ provide a commercial version of QuickCheck for
  Erlang\cite{arts2006}.
\item The popular JUnit library for Java provides built-in support for parameterised
  tests\footnote{\url{https://github.com/junit-team/junit4/wiki/Parameterized-tests}},
  whereas the
  junit-quickcheck\footnote{\url{https://github.com/pholser/junit-quickcheck}}
  library provides a more traditional property testing experience.
\item The Go standard library provides a
  testing/quick\footnote{\url{https://golang.org/pkg/testing/quick/}} module.
\item The
  Hypothesis\footnote{\url{https://github.com/HypothesisWorks/hypothesis-python}}
  tool for Python implements property-based testing, but cannot do automated
  type-directed input value generation due to Python's dynamic nature.
\item NUnit, the common .NET unit testing library, allows tests to be
  parameterised with random numeric
  values\footnote{\url{https://github.com/nunit/docs/wiki/Random-Attribute}},
  and with combinations of values of arbitrary
  types\footnote{\url{https://github.com/nunit/docs/wiki/Values-Attribute}}.
\end{itemize}

Although QuickCheck was arguably the first tool to popularise this style of
testing, and did so in Haskell, it is increasingly gaining recognition by
programmers of other languages as a good way to overcome the pitfalls and
difficulties of traditional unit testing techniques.

\section{Searching for Properties}
\label{sec:property_testing-gen}

As we have seen, properties can be used as expressive and declarative
test cases.  However, coming up with properties can be difficult.  To
help the programmer, tools exist to discover properties.  These tools
are based on testing or examples, and so any properties found are
merely conjectures supported by a finite amount of evidence.  Despite
that, such properties are surprisingly accurate in practice, and often
lead to a deeper understanding of the program under test.

\paragraph{Testing}
QuickSpec\cite{claessen2010,smallbone2017} and
Speculate\cite{braquehais2017} are tools for Haskell which
automatically discover equational laws of pure functions.  Both are
based on generating and testing candidate expressions.  Speculate,
unlike QuickSpec, can discover inequalities and conditional equations.
Neither supports functions with effects or generating lambda-terms.

When provided with the integers \verb|0| and \verb|1| and the
functions \verb|id|, \verb|abs|, and \verb|(+)|, Speculate prints the
properties in \cref{lst:arith_props}.  QuickSpec discovers similar
properties to \cref{lst:arith_props0}, but not the inequalities and
conditional equations.

\begin{listing}
\begin{sublisting}{\textwidth}
\centering
\begin{cminted}{text}
           id x == x
          x + 0 == x
    abs (abs x) == abs x
          x + y == y + x
    abs (x + x) == abs x + abs x
abs (x + abs x) == x + abs x
abs (1 + abs x) == 1 + abs x
    (x + y) + z == x + (y + z)
\end{cminted}
\caption{Equational laws.}\label{lst:arith_props0}
\end{sublisting}

% [layout hack]: no gap between the listings otherwise
\vspace{2.5em}

\begin{sublisting}{\textwidth}
\begin{minipage}[t]{0.45\textwidth}
\begin{minted}{text}
          x <= abs x
          0 <= abs x
          x <= x + 1
          x <= x + abs y
          x <= abs (x + x)
          x <= 1 + abs x
          0 <= x + abs x
      x + y <= x + abs y
abs (x + 1) <= 1 + abs x
\end{minted}
\end{minipage}
\begin{minipage}[t]{0.55\textwidth}
\begin{minted}{text}
    x <= y ==> x <= abs y
abs x <= y ==> x <= y
 abs x < y ==> x <  y
    x <= 0 ==> x <= abs y
abs x <= y ==> 0 <= y
 abs x < y ==> 1 <= y
    x == 1 ==> 1 == abs x
     x < 0 ==> 1 <= abs x
    y <= x ==> abs (x + abs y) == x + abs y
    x <= 0 ==>       x + abs x == 0
abs x <= y ==>     abs (x + y) == x + y
abs y <= x ==>     abs (x + y) == x + y
\end{minted}
\end{minipage}
\caption{Inequalities and conditional equations.}\label{lst:arith_props1}
\end{sublisting}
\caption{Properties of arithmetic, discovered by Speculate.}\label{lst:arith_props}
\end{listing}

\paragraph{Machine learning}
The Daikon\cite{ernst2007} tool discovers \emph{likely invariants} of
C, C++, Java, and Perl programs.  It observes variables in memory
during the execution of a program, and applies machine learning
techniques to discover properties that seem to hold.  These properties
may include: pre- and post-conditions of statements, and equational
relationships between variables at a given program point and functions
from a library.  Daikon does not synthesise and test program terms,
however.  It is only able to discover invariants which exist in the
original program.  In contrast, the other tools described can discover
properties that do not appear in the original program at all.

\paragraph{Concurrency testing}
A variant of the Daikon tool discovers likely invariants of concurrent
C and C++ programs using code instrumentation and systematic
concurrency testing techniques\cite{kusano2015}.  The invariants it
finds are so-called \emph{transition invariants} that capture the
relations amongst mutable state shared between threads.

\begin{listing}
\centering
\begin{minipage}[t]{0.3\textwidth}
\begin{minted}{c}
/* Thread 1 */
p = &A
if (p != NULL) {
  p->x += 10;
}
\end{minted}
\end{minipage}
\begin{minipage}[t]{0.3\textwidth}
\begin{minted}{c}
/* Thread 2 */
p = NULL;
\end{minted}
\end{minipage}
\caption{Two threads accessing a shared pointer.}\label{lst:cthreads}
\end{listing}

\Cref{lst:cthreads} shows two threads accessing a shared pointer.  If
the second thread sets \verb|p| to \verb|NULL| after the first checks
that it is not but before dereferencing it, then an error will occur.
Correct executions of the program will produce the invariant
\verb|p == orig(p)| for that if-statement, meaning that \verb|p| is
unchanged.  Buggy executions will not.  The authors argue that
examining discrepancies between invariants can lead to greater
understanding of the software under test and diagnosis of errors.

The \textsc{Determin} tool\cite{burnim2010} infers deterministic
specifications for procedures which make use of internal parallelism,
of which a program may have many.  These specifications are in the
form of a precondition and a postcondition over program states.  If we
use $P(s, \sigma)$ to denote the resulting program state after
executing procedure $P$ in an initial state $s$ with a schedule
$\sigma$, then specifications are of the form,

\[
\forall s, s', \sigma, \sigma'.~~
\mathrm{Pre}\left(s, s'\right) \implies
\mathrm{Post}\left(P\left(s,\sigma\right),P\left(s', \sigma'\right)\right)
\]

\noindent
For example, if the precondition is $s = s'$ and the postcondition is
$v = v'$, where $v$ is some variable assigned to by $P$, then the
overall specification can be read as ``for all schedules $\sigma$ from
state $s$, the variable $v$ gets the same value (if execution
terminates).''

\paragraph{Example-driven property discovery}
The Bach\cite{smith2017} tool uses a database of examples of
input/output values from functions to synthesise properties using a
Datalog-based oracle.  As it is based on examples, it is not tied to
any particular programming language.  Bach could even be used to
discover properties of hardware components!  Properties are of the
form $G \implies P$, where both $G$ and $P$ are conjunctions of
equalities $f(x) = y$, where $f$ is some function in the database, and
$x$ and $y$ may be constants or variables.  It uses a notion of
\emph{evidence} to decide whether an inferred property holds: negative
evidence consists of counterexamples; positive evidence consists of
witnesses.  Bach crucially requires functions to have at most one
output for each distinct input, to construct negative evidence.
