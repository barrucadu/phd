\blindtext

\section{Terminology: Parallelism vs Concurrency}
\label{sec:intro-parconc}

In many fields, \emph{parallel} and \emph{concurrent} are synonyms, both referring to the act of
doing multiple things at once.  In programming, they refer to different but related concepts.

A \emph{parallel} program uses a multiplicity of hardware to compute different aspects of a result
simultaneously.  The goal is to arrive at the overall result more quickly.  For example, the x86
assembly instruction \verb#PMULHUW# computes the element-wise multiplication of two vectors, each
multiplication simultaneously: it (amongst others) enables parallelism.

A \emph{concurrent} program uses a notion of multiple independently executing threads of control to
structure the program.  These threads conceptually execute at the same time (their effects may be
interleaved).  Whether threads actually do execute simultaneously is an implementation detail.  A
concurrent program can execute on a single-core machine through interleaved sequential execution
just as it can be executed on a multi-core machine in parallel.

Concurrency is often implemented using parallelism.  Indeed a concurrency abstraction can even
guarantee parallelism (given suitable hardware), for example by having the ability to restrict the
execution of individual threads to given processor cores.

This thesis is mostly concerned with concurrency, but parallelism does rear its head in the
discussion of \emph{relaxed memory} in Chapter~\ref{chp:dejafu}.

\section{Assumed Haskell Knowledge}
\label{sec:intro-assumed}
\blindtext

\section{Goals and Contributions of this Thesis}
\label{sec:intro-contributions}
\blindtext

\section{Roadmap}
\label{sec:intro-roadmap}

This thesis is divided into three broad parts:

\begin{itemize}
\item Part~\ref{part:dejafu} is about \dejafu{}, our tool for testing concurrent Haskell programs.
  Chapter~\ref{chp:concurrent_haskell} gives an introduction to concurrency in Haskell.
  Chapter~\ref{chp:sct} discusses the theory behind \emph{testing} concurrent programs.
  Chapter~\ref{chp:dejafu} gives an account of the \dejafu{} tool itself, covering the scope,
  implementation, some case studies, and evaluation.  Finally, Chapter~\ref{chp:algorithms}
  discusses an alternative scheduling algorithm when testing a concurrent program.

\item Part~\ref{part:coco} is about CoCo, our tool for discovering properties of concurrent
  functions.  Chapter~\ref{chp:property_testing} gives an introduction to property testing in
  Haskell.  Chapter~\ref{chp:coco} gives an account of the CoCo tool itself, covering the scope,
  implementation, some case studies, and evaluation.  Finally, Chapter~\ref{chp:coco_and_dejafu}
  discusses using the properties discovered by CoCo as test cases in \dejafu{}.

\item Lastly, in Part~\ref{part:end} we discusses our conclusions (Chapter~\ref{chp:conclusions})
  and suggest possible future work (Chapter~\ref{chp:future_work}).
\end{itemize}

Chapters~\ref{chp:concurrent_haskell} and~\ref{chp:property_testing} should be accessible to anyone
with the assumed knowledge detailed in \S\ref{sec:intro-assumed}\footnote{Or to the particularly
  motivated beginner who also has an introductory Haskell tutorial open.}.
