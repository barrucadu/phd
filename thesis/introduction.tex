There is a tension between theory and practice in software
engineering.  Whenever one programmer suggests some sophisticated
technique or formalism, another will question its applicability to the
\emph{real world}, a nebulous and undefined place.  Here is an
example:

\begin{description}
\item[Alice] ``If you want a reliable concurrent program, you have to
  model check your core algorithms.''
\item[Bob] ``Model checking doesn't scale to real-world concurrent
  programs, you just have to stress test them.''
\end{description}

Bob's concern is not unfounded.  While model checking can prove the
absence of bugs, it can be difficult or resource-intensive to use.
Whereas stress testing, aided by dynamic analyses like Clang's
ThreadSanitizer\footnote{\url{https://clang.llvm.org/docs/ThreadSanitizer.html}}
or Go's data race
detector\footnote{\url{https://golang.org/doc/articles/race_detector.html}},
is often effective at finding flaws.  Where testing falls down,
however, is answering questions like:

\begin{itemize}
\item How do we ensure that we're covering a variety of schedules?
\item How do we know a that bug has been fixed?
\item \emph{How much testing is enough?}
\end{itemize}

In this thesis, we follow a middle path: between the familiarity of
testing and the power of model checking.  By leveraging
\emph{systematic concurrency testing}, we enable programmers to test
their concurrent programs deterministically, and confidently.

We use Haskell is used in this thesis.  \Cref{app:haskell} gives a
brief introduction to Haskell for the reader already somewhat familiar
with functional programming.

\section{Parallelism vs Concurrency}
\label{sec:intro-parconc}

In many fields, `parallelism' and `concurrency' are synonyms, both
referring to doing multiple things at once.  In programming, they
refer to different but related concepts.

\paragraph{Parallelism}
A parallel program uses a multiplicity of hardware to compute
different aspects of a result simultaneously.  The goal is to arrive
at the overall result more quickly.  For example, the x86 assembly
instruction \verb#PMULHUW# computes the element-wise multiplication of
two vectors, performing each multiplication simultaneously: it enables
parallelism.

\paragraph{Concurrency}
A concurrent program uses a notion of multiple threads of control to
structure the program.  These threads conceptually execute
independently and the same time.  Whether threads actually do execute
simultaneously is an implementation detail.  A concurrent program can
execute on a single-core machine through interleaved sequential
execution just as it can execute on a multi-core machine in parallel.
A concurrency abstraction can guarantee parallelism (given suitable
hardware), for example by having the ability to restrict the execution
of individual threads to given processor cores.

This thesis is concerned with concurrency, but parallelism does rear
its head in the discussion of \emph{relaxed memory} in
\Cref{chp:dejafu}.

\section{Goals and Contributions of this Thesis}
\label{sec:intro-contributions}

The primary contribution of this thesis is to demonstrate that
concurrency testing techniques, typically described in the context of
a simple core language, can be successfully applied to languages with
rich concurrency abstractions.  This demonstration is in the form of a
library for testing concurrent Haskell programs.

Our contributions are:

\begin{itemize}
\item A library for effectively testing concurrent Haskell programs.
\item A convincing demonstration that concurrency testing techniques
  work well in a rich setting.
\item A new scheduling algorithm for randomised testing.
\item A tool for discovering properties of concurrent Haskell
  functions.
\end{itemize}

The overall motivation of this research has been to develop tools
which make it easier for programmers to write correct concurrent
programs.

\section{Roadmap}
\label{sec:intro-roadmap}

This thesis is divided into three parts:

\paragraph{\Cref{part:review}}
We present the context and background of the work.
\Cref{chp:concurrent_haskell} gives an introduction to concurrency in
Haskell.  \Cref{chp:sct} discusses the theory behind \emph{testing}
concurrent programs.  Finally, \Cref{chp:property_testing} gives an
introduction to property testing in Haskell.

\paragraph{\Cref{part:testing}}
We present our contributions.  \Cref{chp:dejafu} gives an account of
the \dejafu{} tool for testing concurrent Haskell programs, covering
the scope, implementation, and some case studies.
\Cref{chp:algorithms} discusses an alternative scheduling algorithm
for testing concurrent programs.  Finally, \Cref{chp:coco} gives an
account of the CoCo tool for discovering properties of concurrent
Haskell programs, covering the scope, implementation, some case
studies, and shows how it connects to \dejafu{}.

\paragraph{\Cref{part:end}}
We evaluate the work and discuss our conclusions in
\Cref{chp:conclusions} and suggest possible future work in
\Cref{chp:future_work}.
