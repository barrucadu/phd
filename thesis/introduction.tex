There is a tension between theory and practice in software
engineering.  Whenever one programmer suggests some sophisticated
technique or formalism, another will question its applicability to the
\emph{real world}, a nebulous and under-specified place.  For example:

\begin{description}
\item[Alice] ``If you want a reliable concurrent program, you have to
  model check your core algorithms.''
\item[Bob] ``Model checking doesn't scale to real-world concurrent
  programs, you just have to stress test them.''
\end{description}

Bob's concern is not unfounded.  While model checking can prove the
absence of bugs, it can be difficult or resource-intensive to use.
Whereas stress testing, aided by dynamic analyses like Clang's
ThreadSanitizer \parencite{serebryany2009} or Go's data race
detector \parencite{golang2017}, is often effective at finding flaws.  Where
the testing of concurrent programs falls down, however, is answering
questions like:

\begin{itemize}
\item How do we ensure that we're covering a variety of schedules?
\item How do we know a that bug has been fixed?
\item How much testing is enough?
\end{itemize}

In this thesis, we follow a middle path between the familiarity of
testing and the power of model checking.  By using \emph{systematic
  concurrency testing}, we enable programmers to test their concurrent
programs deterministically, and confidently.

A concern in academia is the tension between theoretical novelty and
practical utility.  Too often programs written during research are
abandoned as unpolished prototypes.  This practice harms the spread of
ideas from theory into practice, which is particularly regrettable
when the ideas are intended to make programmers' jobs easier.  We
adopt a stance more in favour of practical utility than is perhaps
typical.  By producing polished and featureful tools, we enable
programmers to benefit immediately from our work.

We use Haskell as the implementation language, and the source of the
concurrency abstraction we target, in this thesis.  However, our work
is not tied to Haskell.  \Cref{app:haskell} gives a brief introduction
to Haskell for the reader already somewhat familiar with functional
programming in other languages.

\section{Parallelism vs Concurrency}
\label{sec:intro-parconc}

The terms \emph{parallelism} and \emph{concurrency} are broadly, but
not quite, synonymous.  Following the lead of \cite{peytonjones1996},
we use them to refer to different but related concepts:

\paragraph{Parallelism}
A parallel program uses a multiplicity of hardware to compute
different aspects of a result simultaneously.  The goal is to arrive
at the overall result more quickly.  For example, the x86 assembly
instruction \verb#PMULHUW# computes the element-wise multiplication of
two vectors, performing each multiplication simultaneously: it enables
parallelism.

\paragraph{Concurrency}
A concurrent program uses multiple threads of control to structure the
program.  These threads conceptually execute independently and at the
same time.  But whether threads do execute simultaneously is an
implementation detail.  A concurrent program can execute on a
single-core machine through interleaved sequential execution just as
it can execute on a multi-core machine in parallel.  A concurrency
abstraction can guarantee parallelism (given suitable hardware), for
example by having the ability to restrict the execution of individual
threads to given processor cores.

It is tempting to think of parallelism as being \emph{semantically
  invisible}: not changing the result of a program, merely making it
faster.  However, on modern processors, parallelism is semantically
\emph{visible}.  This thesis is mostly concerned with concurrency, but
the \emph{relaxed memory} behaviour of modern processors, an artefact
of parallelism, appears in \Cref{chp:dejafu}.

\section{Goals and Contributions of this Thesis}
\label{sec:intro-contributions}

The overall motivation of this research has been to develop tools
which make it easier for programmers to write correct concurrent
programs.

The primary goal of this thesis is to demonstrate that concurrency
testing techniques, typically described in the context of a simple
core language, can be successfully applied to languages with rich
concurrency abstractions.  Specifically, we want:

\begin{itemize}
\item A concurrency testing tool which simultaneously supports
  multiple aspects of concurrency which are traditionally considered
  difficult: such as relaxed memory, software transactional memory,
  and inter-thread signals.
\item To show that supporting these features does not render a tool
  too expensive, in time or space, to be of practical value.
\end{itemize}

To meet and demonstrate our objectives, we develop libraries and tools
for testing Concurrent Haskell programs, and evaluate their
effectiveness on sample applications.

Our major contributions are:

\begin{itemize}
\item A library for effectively testing Concurrent Haskell programs,
  in \Cref{chp:dejafu}.  We demonstrate its effectiveness with case
  studies of three concurrency-using Haskell libraries.
\item A new scheduling algorithm for randomised testing to allow
  testing programs where complete testing does not scale, in
  \Cref{chp:algorithms}.  We evaluate its bug-finding ability on a
  standard set of benchmarks.
\item A tool for discovering properties of Haskell functions operating
  on shared mutable state in the presence of concurrent interference,
  in \Cref{chp:coco}.  We give case studies of three concurrent data
  structures.
\end{itemize}

In achieving these major contributions, we also achieve several
smaller ones along the way:

\begin{itemize}
\item An abstraction over the GHC Haskell concurrency API, extended
  with named threads and shared variables to make debugging easier, in
  \Cref{sec:dejafu-monadconc}.
\item An operational semantics for Concurrent Haskell, in
  \Cref{sec:dejafu-semantics}.
\item A method for soundly incorporating daemon threads, threads which
  are automatically terminated when the main thread terminates, into a
  concurrency testing setting, in \Cref{sec:dejafu-testing}.
\item An algorithm for semantics-preserving simplification of
  execution traces, in \Cref{sec:dejafu-traces}.
\item Case studies of applying concurrency testing to three Haskell
  libraries, in \Cref{sec:dejafu-casestudies}.
\item A method for generating program fragments containing lambda
  terms in a restricted setting, in \Cref{sec:coco-hiw-gen}.
\end{itemize}

\section{Chapter Preview}
\label{sec:intro-roadmap}

This thesis is divided into three parts:

\paragraph{\Cref{part:review}}
We present the context and background of the work.
\Cref{chp:concurrent_haskell} gives an introduction to concurrency in
Haskell.  \Cref{chp:sct} discusses the theory behind \emph{testing}
concurrent programs.  Finally, \Cref{chp:property_testing} gives an
introduction to property testing in Haskell.

\paragraph{\Cref{part:testing}}
We present our contributions.  \Cref{chp:dejafu} gives an account of
the \dejafu{} tool for testing concurrent Haskell programs, discussing
the scope, implementation, and some case studies.
\Cref{chp:algorithms} discusses an alternative scheduling algorithm
for testing concurrent programs.  Finally, \Cref{chp:coco} gives an
account of the CoCo tool for discovering properties of concurrent
Haskell programs, discussing the scope, implementation, and some case
studies, and finally shows how it connects to \dejafu{}.

\paragraph{\Cref{part:end}}
We present our overall conclusions in \Cref{chp:conclusions} and
suggest possible future work in \Cref{chp:future_work}.

\paragraph{Source availability}
The \dejafu{} and CoCo tools we develp in \Cref{part:testing} are
available on GitHub:

\begin{itemize}
\item \url{https://github.com/barrucadu/dejafu}
\item \url{https://github.com/barrucadu/coco}
\end{itemize}

% [layout hack]: there's so little on this page the indent looks
% really weird
\noindent
\dejafu{} and its related libraries are also available on Hackage:

\begin{itemize}
\item \url{https://hackage.haskell.org/package/concurrency}
\item \url{https://hackage.haskell.org/package/dejafu}
\item \url{https://hackage.haskell.org/package/hunit-dejafu}
\item \url{https://hackage.haskell.org/package/tasty-dejafu}
\end{itemize}
