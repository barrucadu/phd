Correctness of testing asks whether the schedule prefixes generated by
the partial-order reduction mechanism are valid, and are there any
results possible in real-world execution for which no schedule will be
generated? This is definitely \emph{not} the same as asking if every
real-world schedule will be generated by the testing framework, as
that is precisely what partial-order reduction tries to avoid.

\subsection{Prefix Validity}
\label{sec:correctness-testing-validity}

Multiple executions with different schedules are stored internally as
a tree, with each path from the root to a leaf corresponding to a
complete execution:

\begin{haskellcode}
data BPOR = BPOR
  { runnable :: Set ThreadId
  , todo     :: Set Threadid
  , done     :: Map ThreadId BPOR
  , action   :: Maybe ThreadAction
  }
\end{haskellcode}

The \verb|runnable| field is the set of all threads runnable at that
point; \verb|todo| is the decisions still to try making; \verb|done|
is the decisions already made; and \verb|action| is what was done at
this step. \verb|action| is a \verb|Maybe| value, because initially no
action has been performed, as the computation hasn't yet started.

There is a unique initial state, where only the initial thread is
runnable and nothing has been done:

\begin{haskellcode}
initialState :: BPOR
initialState = BPOR (singleton 0) (singleton 0) empty Nothing
\end{haskellcode}

There are some basic well-formedness invariants associated with a
\verb|BPOR| value:

\begin{itemize}
\item Every decision in the to-do set is possible:
  $\mathrm{todo} \subseteq \mathrm{runnable}$

\item Every decision in the done map is possible:
  $\dom \mathrm{done} \subseteq \mathrm{runnable}$

\item No decision that has been done is in the to-do set:
  $\mathrm{todo} \cap \dom \mathrm{done} = \varnothing$

\item These properties hold recursively:
  $\forall p \in \ran \mathrm{done}.~\wellf{p}$
\end{itemize}

Some work has been started in the Isabelle/HOL theorem prover to
formalise part of the recursive loop in \verb|sctBounded| (see
\sect{sct}{por}) and to prove that the invariants are preserved,
assuming that the stepwise executor is correct. It is hoped that
schedule prefix validity will follow from this. Specifically, the
things to be proved are:

\begin{itemize}
\item A prefix produced by \verb|next| is valid if the \verb|BPOR|
  tree is well-formed; furthermore, it consists of a sequence of
  decisions that have already been made and is terminated by a single
  decision from a to-do set.

\item \verb|next| returns \verb|Nothing| if and only if the
  \verb|todo| field of every node in the \verb|BPOR| tree is empty.

\item \verb|grow| adds the information in a trace to the \verb|BPOR|
  tree, making no other changes.
\end{itemize}

Data structure invariants are an important property to verify, as if
they are broken any assumptions made in the rest of the code cannot be
trusted.

\subsection{Result Completeness}
\label{sec:correctness-testing-complete}

The simplest notion of completeness of interest here is that for all
results possible by executing a given program for real, the
partial-order reduction framework can give that result.

However, as schedule bounding is involved, this is clearly not the
case. Therefore, there are two different notions of completeness which
are of interest:

\begin{itemize}
\item If the bounds are all set to $\infty$, all results possible
  under real execution show up under \dejafu{} execution.

\item For all sets of bounds, all results possible under real
  execution subject to those bounds show up under \dejafu{} execution
  with the same bounds.
\end{itemize}

The former corresponds to the correctness of partial-order reduction
with no bounds, and does not imply the latter. The latter implies the
former, and is the more interesting property. The latter is what we
really want of our testing framework.

The proof would need to proceed by first showing that the dependency
relation is correct: that only actions related by the dependency
relation can influence each others results. It's not clear how to
approach this, as it relies on the implementation of the actions. Once
the correctness of the dependency relation is established, it must be
shown that the partial-order reduction only prunes schedules where
there is no dependency.
