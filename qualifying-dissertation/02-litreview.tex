\chapter{Literature Review}
\label{sec:litrev}

% "give a thorough account of previous and current work in the field,
% with ample citations of relevant literature; assess the current
% state of the field, for example, discuss assumptions generally made
% and their validity, limitations generally accepted and their
% necessity, major open problems and prospects for their solution and
% the relative strengths and weaknesses of the major lines of work
% pursued to date."

This chapter motivates the field of runtime verification by first
discussing some of the techniques and difficulties of static analysis
and verification in \sect{litrev-stat}. Runtime Verification is then
explored in \sect{litrev-run}, focusing on the Design by Contract and
trace analysis approaches. Runtime Enforcement, an extension of
Runtime Verification which aims to guarantee correct functioning by
correcting deviations, is discussed in
\sect{litrev-run-enforce}. Finally, the section is concluded by a
discussion of performing offline analysis of runtime-gathered data in
\sect{litrev-run-offline}, and some of the major open problems in the
field in \sect{litrev-run-probs}. Case studies of particular
approaches are given throughout.

The chapter closes with a discussion of the combination of both
runtime and static verification in \sect{litrev-both}, with some open
problems in this area in \sect{litrev-both-probs}.

\section{Static Analysis \& Verification}
\label{sec:litrev-stat}

Static analysis is the process of automatically proving nontrivial
properties of programs without executing them\cite{secure}, in effect
reasoning over all possible executions. Analysis techniques range from
the simple, such as type systems\cite{types}, to the complex, such as
memory safety\cite{infer} and deadlock freedom\cite{racerx}. Static
analysis can be a very useful technique, achieving powerful results
about our programs, and giving very strong guarantees of their
behaviour.

Static verification typically refers to verification of correctness
properties of programs beyond typical static analyses, such as proofs
of correctness.

Unfortunately, most properties of Turing-complete systems are
undecidable\cite{turing}\cite{rice} meaning there is a fundamental
limitation on what can be achieved with a fully automated program
analysis. Proof assistants\cite{proofassists} are an attempt to work
around this issue, where as much is automated as possible, but where
key decisions in the proof process are made by a guiding human
overseer. Another approach is to use non-Turing complete systems,
which are typically much more decidable, such as (most) type systems.

\subsection{Proofs of Software Correctness}
\label{sec:litrev-stat-proof}

\todo{Outline of the process of proving software correct, why this is
  good if possible, where this sort of thing is done.}

\subsection{Case Study: Type Systems}
\label{sec:litrev-stat-types}

\todo{Quick history of static type systems, compare primitive ones
  (eg, ALGOL) and modern dependent type systems (eg, Agda), taking
  care to highlight decidability issues that arise with increased
  complexity.}

\section{Runtime Verification}
\label{sec:litrev-run}

\todo{Intro to RV, why it's often acceptable, split focus on just
  monitoring and also enforcement.}

\subsection{Design by Contract}
\label{sec:litrev-run-dbc}

\todo{Intro to DbC, how we can check contracts at runtime, dsl/host
  language choice.}

\subsubsection{Case Study: Java Modelling Language}
\label{sec:litrev-run-dbc-jml}

\todo{Critical evaluation of JML, talk a little about BML as well.}

\subsubsection{Case Study: jContractor}
\label{sec:litrev-run-dbc-jcon}

\todo{Critical evaluation of jContractor.}

\subsection{Trace Analysis}
\label{sec:litrev-run-trace}

\todo{Intro to trace analysis, difference in sorts of properties we
  can talk about with contracts and with traces, how we can monitor
  traces at runtime.}

\subsubsection{Case Study: Regular Expressions}
\label{sec:litrev-run-trace-regex}

\todo{Critical evaluation of regex, in terms of what sorts of
  properties we can state and how used it is.}

\subsubsection{Case Study: Linear Temporal Logic}
\label{sec:litrev-run-trace-ltl}

\todo{Critical evaluation of ltl, in terms of what sorts of properties
  we can state (compare with regex), and how used it is.}

\subsection{Combined Contract/Trace Monitors}
\label{sec:litrev-run-trcon}

\todo{How we can combine the two.}

\subsection{Runtime Enforcement}
\label{sec:litrev-run-enforce}

\todo{Overview of enforcement, potential pros and cons.}

\subsection{Offline Analysis}
\label{sec:litrev-run-offline}

\todo{Overview of offline analysis, potential pros and cons.}

\subsection{Open Problems}
\label{sec:litrev-run-probs}

\todo{Big open problems in RV.}

\section{Combined Static/Runtime Verification}
\label{sec:litrev-both}

\todo{Why combining both might be good, outline of how we can do that.}

\subsection{Static-informed Runtime Verification}
\label{sec:litrev-both-sir}

\todo{Using static analysis to inform or optimise runtime
  verification.}

\subsection{Runtime-informed Static Verification}
\label{sec:litrev-both-ris}

\todo{Using runtime verification to provide evidence for or discharge
  static obligations.}

\subsection{Open Problems}
\label{sec:litrev-both-probs}

\todo{Big open problems in S+R V.}
